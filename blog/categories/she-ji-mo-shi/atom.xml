<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 设计模式 | 李天炜]]></title>
  <link href="http://tianweili.github.io/blog/categories/she-ji-mo-shi/atom.xml" rel="self"/>
  <link href="http://tianweili.github.io/"/>
  <updated>2015-03-24T23:05:02+08:00</updated>
  <id>http://tianweili.github.io/</id>
  <author>
    <name><![CDATA[李天炜 litianwei2013[AT]gmail.com]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计模式六大原则 - 开闭原则]]></title>
    <link href="http://tianweili.github.io/blog/2015/03/24/open-close-principle/"/>
    <updated>2015-03-24T22:03:39+08:00</updated>
    <id>http://tianweili.github.io/blog/2015/03/24/open-close-principle</id>
    <content type="html"><![CDATA[<p>开闭原则是设计模式六大原则中最重要也是最“虚”的一个原则。为什么说它最重要呢？因为前面五大原则的目的都是为了实现这个开闭原则，开闭原则相当于它们的主旨思想。为什么说它“虚”呢？因为开闭原则只是个指导思想，不像另外五大原则都有具体可行的指导方法。废话不多说，我们开始了解什么是开闭原则吧。</p>

<!--more-->


<p>原文链接：<a href="http://tianweili.github.io/blog/2015/02/12/law-of-demeter/">http://tianweili.github.io/blog/2015/02/12/law-of-demeter/</a></p>

<h2>定义</h2>

<p>Software entities like classes, modules and functions shoule be open for extension but closed for modifications.（一个软件实体如类，模块和函数应该对扩展开放，对修改关闭。）</p>

<p>开闭原则的定义很短，就是对扩展开放，对修改关闭。但是为什么要遵守这一个原则呢？</p>

<p>做过实际项目的筒子们应该都会深有体会，一个软件在其生命周期内都会发生很多变化，这几乎是不可避免的。无论是需求的变化、业务逻辑的变化、程序代码的变化等等，这些变化都有可能对整个软件的稳定性造成一定的威胁。</p>

<p>而开闭原则就是应对这些变化的，它告诉我们应该通过扩展来实现变化，而不是通过修改已有的代码。</p>

<h2>例子</h2>

<p>我记得上中学的时候，每次考试出成绩的时候老师都会站在讲台上一遍发卷子一遍念出每位同学的分数，下面的学生们心理都暗自捏了一把汗。对于念出自己分数的同学，如果考得好，走上讲台领会卷子，自然心中倍感自豪。但是如果考得不好，一路上感觉都很惭愧啊，此时就很不希望老师当众把自己分数念出来。</p>

<p>下面我们来看看这种场景下的UML类图：</p>

<p><img src="http://7u2i08.com1.z0.glb.clouddn.com/design-pattern/open-close-principle1.png"></p>

<p>程序代码如下：</p>

<p>学生类，每个学生都有姓名和成绩：</p>

<pre><code class="java">public class Student {

    private String name;
    private String grade;

    public Student(String name, String grade) {
        this.name = name;
        this.grade = grade;
    }

    public String getName() {
        return name;
    }

    public String getGrade() {
        return grade;
    }
}
</code></pre>

<p>老师类，每个老师管理一群的学生：</p>

<pre><code class="java">import java.util.ArrayList;
import java.util.List;

public class Teacher {

    public final static List&lt;Student&gt; students = new ArrayList&lt;Student&gt;();

    static {
        students.add(new Student("张三", "60"));
        students.add(new Student("李四", "70"));
        students.add(new Student("王五", "80"));
    }
}
</code></pre>

<p>场景类：</p>

<pre><code class="java">public class Client {
    public static void main(String[] args) {
        Teacher teacher = new Teacher();
        for (Student student : teacher.students) {
            System.out.println("姓名：" + student.getName() + " 成绩：" + student.getGrade());
        }
    }
}
</code></pre>

<p>输出结果：</p>

<pre><code>姓名：张三 成绩：60
姓名：李四 成绩：70
姓名：王五 成绩：80
</code></pre>

<p>最后王同学看到自己成绩不错，裂开嘴笑了。而张同学就惨了，差点不及格，在全班同学的哄笑中领走了试卷。</p>

<h2>更改需求</h2>

<p>因为这种当众念出学生成绩的行为可能为伤害到一些成绩不是那么好的同学的自尊心，所以临时决定要对这种念出分数的方式进行改革。把同学们的成绩按照级别来分，分别有优秀，良好，一般，及格，不及格这几种。这样可以照顾成绩不好的同学的自尊心。</p>

<p>那么我们怎么根据这种需求来更改我们的软件呢？</p>

<p>有人说直接修改Student类的getGrade方法不就行了嘛。可能有很多人在实际项目中都是这么做的，但是这就违背了开闭原则，开闭原则要求我们尽量不要修改已有的代码，尽量通过扩展来实现改变。</p>

<p>因为我们举的例子比较简单，但是在实际复杂的项目中，首先理解已有的方法业务逻辑可能就不是一件容易的事情，更何况如果再有其他实体类需要调用你已有的方法，如果你修改了这个方法，所有调用这个方法的代码都得需要找到并修改，这是一件既困难又不安全的做法。</p>

<p>再者说修改了getGrade方法，那么这下只能知道学生成绩处于哪一个层次了，老师也无法知道学生的具体分数了。</p>

<p>那么我们应该怎么做呢？</p>

<p>既然前门我们知道了开闭原则，我们就要用上。我们可以通过扩展已有的代码来实现改变，可以增加一个LevelStudent来继承Student，并扩展修改getGrade方法。</p>

<p>修改后的UML类图如下所示：</p>

<p><img src="http://7u2i08.com1.z0.glb.clouddn.com/design-pattern/open-close-principle2.png"></p>

<p>增加LevelStudent类代码：</p>

<pre><code class="java">public class LevelStudent extends Student {

    public LevelStudent(String name, String grade) {
        super(name, grade);
    }

    @Override
    public String getGrade() {
        String level = null;
        int grade_ = Integer.valueOf(super.getGrade());
        if (grade_ &gt;= 90) {
            level = "优秀";
        } else if (grade_ &lt; 90 &amp;&amp; grade_ &gt;= 80) {
            level = "良好";
        } else if (grade_ &lt; 80 &amp;&amp; grade_ &gt;= 70) {
            level = "一般";
        } else if (grade_ &lt; 70 &amp;&amp; grade_ &gt;= 60) {
            level = "及格";
        } else if (grade_ &lt; 60) {
            level = "不及格";
        }
        return level;
    }
}
</code></pre>

<h2>总结</h2>

<p>开闭原则是对扩展开放，对修改关闭。</p>

<p>开闭原则的主旨是为了拥抱变化。</p>

<p>在六大原则中，开闭原则只是一个思想，没有具体实际操作方法。其他五大原则都是为了实现这个开闭思想的一些方法和工具。</p>

<p>想要遵守开闭原则，就需要一个设计合理的系统。可以说在做系统设计的时候就要考虑到未来的扩展和改变。</p>

<p>作者：<a href="http://tianweili.github.io/">李天炜</a></p>

<p>原文链接：<a href="http://tianweili.github.io/blog/2015/02/12/law-of-demeter/">http://tianweili.github.io/blog/2015/02/12/law-of-demeter/</a></p>

<p>转载请注明作者及出处，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[代理模式]]></title>
    <link href="http://tianweili.github.io/blog/2015/03/13/proxy-pattern/"/>
    <updated>2015-03-13T21:55:18+08:00</updated>
    <id>http://tianweili.github.io/blog/2015/03/13/proxy-pattern</id>
    <content type="html"><![CDATA[<p>本文讲述了代理模式，包括了普通代理、强制代理和动态代理。</p>

<!--more-->


<p>原文链接：</p>

<p><a href="http://tianweili.github.io/blog/2015/03/13/proxy-pattern/">http://tianweili.github.io/blog/2015/03/13/proxy-pattern/</a></p>

<h2>介绍</h2>

<p>代理模式属于结构性模式，使用频率很高。</p>

<p>定义：Provide a surrogate or placeholder for another object to control access to it.为其他对象提供一种代理以控制这个对象的访问。</p>

<p>装饰模式、状态模式、策略模式、访问者模式本质上都是在更特殊的场合采用了代理模式。</p>

<h2>UML类图</h2>

<p><img src="http://7u2i08.com1.z0.glb.clouddn.com/design-pattern/proxy-pattern-uml.png"></p>

<p>从以上UML类图中可以看出代理模式主要有三种角色：</p>

<p><strong>抽象主题角色</strong></p>

<p>可以是接口或抽象类，是某类通用业务的定义。</p>

<p><strong>具体主题角色</strong></p>

<p>作为被代理对象，是具体业务的真实执行者。</p>

<p><strong>代理主题角色</strong></p>

<p>是具体主题对象的代理，负责对具体对象的应用，把所有抽象主题定义的方法委托给具体主题对象来实现，它用来在具体主题对象业务处理的前后做一些处理工作。</p>

<h2>代码示例</h2>

<pre><code class="java">/**
 * Abstract subject class.
 */
public interface Subject {
    public void someMethod();
}
/**
 * Real subject class.
 */
public class RealSubject implements Subject {

    private String name;

    public RealSubject(String name) {
        this.name = name;
    }

    @Override
    public void someMethod() {
        System.out.println(name + "'s someMehtod.");
    }
}
/**
 * Proxy class.
 */
public class ProxySubject implements Subject {

    private Subject subject;

    public ProxySubject(Subject subject) {
        this.subject = subject;
    }

    @Override
    public void someMethod() {
        this.before();
        subject.someMethod();
        this.after();
    }

    /**
     * preprocessing
     */
    private void before() {
        // do something...
    }

    /**
     * follow-up processing
     */
    private void after() {
        // do something...
    }
}
</code></pre>

<p>从以上代码可以看出ProxySubject对象还有before和after方法，可以在RealSubject对象的someMethod业务方法前后做一些预处理和善后处理工作。</p>

<p>一个代理类可以代理多个被代理对象，只要是实现同一个接口。当然也可以一个被代理对象就有一个代理类，不过一般是一个接口有一个代理类就够了，在应用时具体是代理哪一个被代理对象，这是由场景类也就是高层模块定义的，根据构造方法的传入哪一个被代理对象参数来决定代理哪一个对象。</p>

<p>构造方法：</p>

<pre><code class="java">public ProxySubject(Subject subject) {
    this.subject = subject;
}
</code></pre>

<p>想代理哪个对象就要传入生成这个对象的实例。</p>

<h2>优点</h2>

<p>各个角色职责清晰，比如被代理对象只需要实现属于自己具体的业务逻辑就行了，不用去关心非本职责的业务处理。其他的一些处理业务可以交给代理类来处理。这样做的好处是编程简洁清晰，业务分明。</p>

<p>扩展性好，具体实现对象的业务发生了变化，只需要修改自身业务处理逻辑，或者增加删减一个实现业务接口的对象，不会影响代理业务。</p>

<p>代理模式可以提供非常好的访问控制，由代理类来控制被代理对象，可以做一些预处理消息，过滤消息，消息转发和善后处理工作等等。</p>

<h2>普通代理和强制代理</h2>

<p>普通代理和强制代理是代理模式的两种不同结构，是根据调用者能够访问到代理对象还是具体对象来区分的。就好比网络上的代理服务器设置分为普通代理和透明代理。普通代理需要用户手动设置代理服务器的IP地址，用户必须知道代理的存在。透明代理就是用户不需要设置代理服务器地址，就可以直接访问，不用知道代理的存在。</p>

<h3>普通代理</h3>

<p>普通代理是用户只能访问代理角色，而不能访问真实角色。</p>

<p>只需要对上面代码稍作改动即可实现普通代理的效果，代码如下：</p>

<pre><code class="java">/**
 * Abstract subject class.
 */
public interface Subject {
    public void someMethod();
}
/**
 * Real subject class.
 */
public class RealSubject implements Subject {

    private String name;

    /**
     * Don't allow client call this.
     */
    public RealSubject(Subject subject, String name) throws Exception {
        if(subject == null) {
            throw new Exception("Don't allow realSubject created!");
        } else {
            this.name = name;
        }
    }

    @Override
    public void someMethod() {
        System.out.println(name + "'s someMehtod.");
    }
}
/**
 * Proxy class.
 */
public class ProxySubject implements Subject {

    private Subject subject;

    /**
     * Client call proxy subject.
     */
    public ProxySubject(String name) {
        try {
            this.subject = new RealSubject(this, name);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void someMethod() {
        this.before();
        subject.someMethod();
        this.after();
    }

    /**
     * preprocessing
     */
    private void before() {
        // do something...
        System.out.println("before ...");
    }

    /**
     * follow-up processing
     */
    private void after() {
        // do something...
        System.out.println("after ...");
    }
}
public class Client {
    public static void main(String[] args) {
        Subject subject = new ProxySubject("ZhangSan");
        subject.someMethod();
    }
}
</code></pre>

<p>运行程序结果如下：</p>

<pre><code>before ...
ZhangSan's someMehtod.
after ...
</code></pre>

<p>在上面RealSubject的构造方法中是通过传入参数subject来限制用户不能实例化自己，当然也可以通过别的一些限制条件，比如类名必须有Proxy等等。</p>

<h3>强制代理</h3>

<p>普通代理是通过代理角色找到真是角色，而强制代理是强制只能通过真实角色查找代理角色来访问，想直接通过实例化代理角色或真实角色都不能访问。</p>

<p>UML类图如下：</p>

<p><img src="http://7u2i08.com1.z0.glb.clouddn.com/design-pattern/proxy-pattern-uml-2.png"></p>

<p>从以上UML类图可以看出Subject接口中添加了个获取代理的接口方法。</p>

<p>代码清单：</p>

<pre><code class="java">/**
 * Abstract subject class.
 */
public interface Subject {
    public void someMethod();
    public Subject getProxy();
}
/**
 * Real subject class.
 */
public class RealSubject implements Subject {

    private String name;
    private Subject proxy;

    public RealSubject(String name) {
        this.name = name;
    }

    @Override
    public void someMethod() {
        if (this.isProxy()) {
            System.out.println(name + "'s someMehtod.");
        } else {
            System.out.println("Only visit proxy class is allowed!");
        }
    }

    @Override
    public Subject getProxy() {
        // appoint proxy class.
        this.proxy = new ProxySubject(this);
        return proxy;
    }

    private boolean isProxy() {
        if (this.proxy == null) {
            return false;
        } else {
            return true;
        }
    }
}
/**
 * Proxy class.
 */
public class ProxySubject implements Subject {

    private Subject subject;

    public ProxySubject(Subject subject) {
        this.subject = subject;
    }

    @Override
    public void someMethod() {
        subject.someMethod();
    }

    @Override
    public Subject getProxy() {
        return this;
    }
}
</code></pre>

<p>当客户端想通过真实角色来访问时，客户端代码如下：</p>

<pre><code class="java">public class Client {
    public static void main(String[] args) {
        Subject realSubject = new RealSubject("ZhangSan");
        realSubject.someMethod();
    }
}
</code></pre>

<p>执行结果：</p>

<pre><code>Only visit proxy class is allowed!
</code></pre>

<p>访问被拒绝，因为它是通过真实角色来直接访问的，而不是通过真实角色来获取代理角色来访问。</p>

<p>当客户端想通过代理角色来访问时，客户端代码如下：</p>

<pre><code class="java">public class Client {
    public static void main(String[] args) {
        Subject realSubject = new RealSubject("ZhangSan");
        Subject proxy = new ProxySubject(realSubject);
        proxy.someMethod();
    }
}
</code></pre>

<p>执行结果：</p>

<pre><code>Only visit proxy class is allowed!
</code></pre>

<p>访问同样被拒绝，因为它是通过代理角色来直接访问的，而不是通过真实角色来获取代理角色来访问。</p>

<p>只有强制客户端通过真实角色来获取代理对象，才能访问。客户端代码如下：</p>

<pre><code class="java">public class Client {
    public static void main(String[] args) {
        Subject realSubject = new RealSubject("ZhangSan");
        Subject proxy = realSubject.getProxy();
        proxy.someMethod();
    }
}
</code></pre>

<p>执行结果：</p>

<pre><code>ZhangSan's someMehtod.
</code></pre>

<p>通过真实角色来获取代理对象访问成功。</p>

<h2>动态代理</h2>

<p>这一节之前所讲的代理其实都是静态代理，它有一个特点就是要在实现阶段就要指定代理类以及被代理者，很不灵活。而动态代理就是在实现阶段不用管代理具体对象，而在运行阶段指定代理哪个对象即可生产代理对象。</p>

<p>基本的UML类图如下所示：</p>

<p><img src="http://7u2i08.com1.z0.glb.clouddn.com/design-pattern/proxy-pattern-uml-3.png"></p>

<p>从类图中可以看出，具体的业务逻辑和代理逻辑是两条线，两者之间没有必然的耦合关系。</p>

<p>InvocationHandler是JDK提供的接口，用来对被代理类的方法进行代理。</p>

<p>注意：<strong>被代理者必须实现一个接口</strong>，否则动态代理无法生成代理对象。</p>

<p>动态代理是根据被代理者的接口生成所有的方法。通过InvocationHandler接口，所有被代理的方法都由InvocationHandler来接管实际的处理逻辑。</p>

<p>代码清单：</p>

<pre><code class="java">/**
 * Abstract subject class.
 */
public interface Subject {
    public void someMethod();
}
/**
 * Real subject class.
 */
public class RealSubject implements Subject {

    private String name;

    public RealSubject(String name) {
        this.name = name;
    }

    @Override
    public void someMethod() {
        System.out.println(name + "'s someMehtod.");
    }
}

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class MyInvocationHandler implements InvocationHandler {

    private Object obj;

    public MyInvocationHandler(Object obj) {
        this.obj = obj;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("before...");
        Object result = method.invoke(obj, args);
        System.out.println("after...");
        return result;
    }
}
</code></pre>

<p>invoke方法是接口InvocationHandler中定义必须实现的，它用来完成对真实方法的调用。</p>

<p>客户端调用代码：</p>

<pre><code class="java">import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;

public class Client {
    public static void main(String[] args) {
        Subject subject = new RealSubject("ZhangSan");

        ClassLoader loader = subject.getClass().getClassLoader();
        Class[] interfaces = subject.getClass().getInterfaces();
        InvocationHandler handler = new MyInvocationHandler(subject);

        Subject proxy = (Subject) Proxy.newProxyInstance(loader, interfaces, handler);
        proxy.someMethod();
    }
}
</code></pre>

<p>执行结果：</p>

<pre><code>before...
ZhangSan's someMehtod.
after...
</code></pre>

<p>从结果中可以看出我们已经达到了代理RealSubject对象的目的。</p>

<p>看了上面的客户端调用代码，我们可以优化一下，将Proxy封装起来，使得调用更简便一些。增加动态代理封装类：</p>

<pre><code class="java">import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;

public class DynamicProxy {

    public static Object newProxyInstance(Object object) {

        ClassLoader loader = object.getClass().getClassLoader();
        Class[] interfaces = object.getClass().getInterfaces();
        InvocationHandler handler = new MyInvocationHandler(object);

        return Proxy.newProxyInstance(loader, interfaces, handler);
    }
}
</code></pre>

<p>客户端调用：</p>

<pre><code class="java">public class Client {
    public static void main(String[] args) {
        Subject subject = new RealSubject("ZhangSan");
        Subject proxy = (Subject) DynamicProxy.newProxyInstance(subject);
        proxy.someMethod();
    }
}
</code></pre>

<h2>动态代理优点</h2>

<p>动态代理拥有以上静态代理所有优点，除此之外还有动态代理的代理对象是在需要的时候动态生成的。</p>

<p>在业务逻辑开发时可以不用管代理业务逻辑，这两条线不会耦合。比如在做具体的业务逻辑设计和实现时不用考虑日志、事务、权限等逻辑处理，这些可以通过动态代理来搞定。</p>

<p>Struts2的Form映射和Spring的AOP（Aspect Oriented Programming）就是动态代理的典型应用。</p>

<p>作者：<a href="http://tianweili.github.io/">李天炜</a></p>

<p>原文链接：<a href="http://tianweili.github.io/blog/2015/03/13/proxy-pattern/">http://tianweili.github.io/blog/2015/03/13/proxy-pattern/</a></p>

<p>转载请注明作者和文章出处，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[抽象工厂模式]]></title>
    <link href="http://tianweili.github.io/blog/2015/03/11/abstract-factory-pattern/"/>
    <updated>2015-03-11T16:32:58+08:00</updated>
    <id>http://tianweili.github.io/blog/2015/03/11/abstract-factory-pattern</id>
    <content type="html"><![CDATA[<p>抽象工厂模式是工厂方法模式的升级版本，主要是引入了一个产品族的概念，将针对单一产品升级到了针对多个产品品种和产品分类。</p>

<!--more-->


<p>原文链接：</p>

<p><a href="http://tianweili.github.io/blog/2015/03/11/abstract-factory-pattern/">http://tianweili.github.io/blog/2015/03/11/abstract-factory-pattern/</a></p>

<h2>介绍</h2>

<p>抽象工厂模式定义：Provide an interface for creating families of related or dependent objects without specifying their concrete classes.为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们具体的类。</p>

<p>抽象工厂模式是工厂方法模式的升级版本，主要是引入了一个产品族的概念，将针对单一产品升级到了针对多个产品品种和产品分类。</p>

<h2>UML类图</h2>

<p><img src="http://7u2i08.com1.z0.glb.clouddn.com/design-pattern/abstract-factory-uml.png"></p>

<p>左边的UML图并不复杂，主要包括2个抽象产品和一个抽象工厂。两个具体实现工厂各对应创建两个不同类别产品。</p>

<h2>产品族和产品等级</h2>

<p>抽象工厂模式关键点在于有了多个产品族。</p>

<p>如上图所示，ProductA1和ProductA2就是属于一个产品族。ProductA1和ProductB1分别属于两个不同的产品族。上面的UML图中有两个产品族。</p>

<p>有几个抽象产品类就有几个产品族。</p>

<p><strong>有几个产品族，在工厂中就有几个创建方法。</strong></p>

<p>继承于同一个抽象产品类的属于不同的产品等级。</p>

<p>ProductA1和ProductA2就是两个产品等级。ProductA1和ProductB1属于同一个产品等级。</p>

<p><strong>有几个产品等级，就有几个实现工厂类。</strong></p>

<p>在每个工厂类中，实现了不同产品族的创建方法。</p>

<h2>代码示例</h2>

<pre><code class="java">public interface AbstractProductA {
    public void method();
}
public class ProductA1 implements AbstractProductA{
    public void method() {
        System.out.println("This is ProductA1.");
    }
}
public class ProductA2 implements AbstractProductA{
    public void method() {
        System.out.println("This is ProductA2.");
    }
}

public interface AbstractProductB {
    public void method();
}
public class ProductB1 implements AbstractProductB{
    public void method() {
        System.out.println("This is ProductB1.");
    }
}
public class ProductB2 implements AbstractProductB{
    public void method() {
        System.out.println("This is ProductB2.");
    }
}

public interface AbstractFactory {
    public AbstractProductA createProductA();
    public AbstractProductB createProductB();
}
public class Factory1 implements AbstractFactory{
    public AbstractProductA createProductA() {
        return new ProductA1();
    }
    public AbstractProductB createProductB() {
        return new ProductB1();
    }
}
public class Factory2 implements AbstractFactory{
    public AbstractProductA createProductA() {
        return new ProductA2();
    }
    public AbstractProductB createProductB() {
        return new ProductB2();
    }
}
</code></pre>

<p>客户端调用</p>

<pre><code class="java">public class Client {
    public static void main(String[] args) {
        AbstractFactory factory1 = new Factory1();
        AbstractFactory factory2 = new Factory2();
        AbstractProductA productA1 = factory1.createProductA();
        AbstractProductB productB1 = factory1.createProductB();
        AbstractProductA productA2 = factory2.createProductA();
        AbstractProductB productB2 = factory2.createProductB();
    }
}
</code></pre>

<p>在上面的客户端调用代码中，没有与具体的产品实现类有关的代码。所以在需要某个具体产品的时候，只需要知道与之对应的工厂来生产就可以了。</p>

<h2>与工厂方法模式的区别</h2>

<p>抽象工厂模式与工厂方法模式的关键不同在于引入了一个产品族的概念，工厂方法模式相当于只有一个产品族，而抽象工厂模式有多个产品族。</p>

<p>在有多个产品族的时候只能使用抽象工厂模式了。</p>

<p>针对多个产品族，每个实现工厂都有相应的创建对应产品的方法。而工厂方法模式中实现工厂中只会有一个创建产品的方法。</p>

<h2>优点</h2>

<p>高层模块只需要知道生产相应产品的工厂类是谁，就能由工厂创建相应的产品对象。而他不用关心具体产品生产过程，符合迪米特法则。只依赖抽象产品，符合依赖倒置原则。使用产品子类替换产品父类，符合里氏替换原则。</p>

<p>不同产品族之间的约束放在工厂类中来实现，不对外公开，封装性好。</p>

<p>想较于工厂方法模式，可以应付产品更为复杂的场合。</p>

<p>在产品等级结构层面上符合开闭原则，增加一个产品等级结构扩展性好。</p>

<h2>缺点</h2>

<p>在产品族层面上不符合开闭原则，增加一个产品族，即相当于增加一个抽象产品时，需要修改大量的其他实现工厂，在产品族层面上扩展性不好。</p>

<h2>适用场景</h2>

<p>当涉及到多个产品族的时候，就需要使用抽象工厂模式了。</p>

<h2>应用实例</h2>

<h3>开发软件应用多个操作系统</h3>

<p>据说抽象工厂模式最初应用于多个操作系统软件开发上，比如要开发一个系统桌面软件，要应用到Windows和Linux操作系统上。那么对于这样的情况我们是不是要分别为两种操作系统开发不同的软件呢？当然不是。对于开发一个桌面软件来说分为界面UI和功能代码等，那么就可以应用抽象工厂模式了，界面UI和功能代码都分别为Windows和Linux开发不同的一套，然后利用工厂在需要Windows的时候调用创建相应的Windows的界面UI和功能代码。</p>

<h3>不同网站爬虫解析</h3>

<p>做过一个爬虫工程，需求是这样的，公司有多个站点，想要去根据搜索关键字获取它们在搜索页面一些要素，比如广告、文章、产品等信息。那么针对这种需求就采用了抽象工厂模式。首先将广告、文章等分别都作为一个产品族，每个网站都是一个产品等级。这样抽象出来的解析广告类、解析文章类等抽象接口，由每个具体产品去实现某个站点的解析广告，另一个产品族的具体产品去实现解析文章类，将具体解析过程封装在了产品内部。再使用相应的工厂来创建一个个产品族内的产品。</p>

<p>关键逻辑删减版类图如下</p>

<p><img src="http://7u2i08.com1.z0.glb.clouddn.com/design-pattern/sitecrawler-uml.png"></p>

<p>这样就实现了良好的封装性，高层模块想调用知道某个网站的一些统计分析数据时，只需要知道相应的工厂来生产就行了，不需要知道具体的实现过程和复杂的处理逻辑。在产品等级也就是网站层面上扩展性好，后来有新增站点的时候，直接增加产品等级，实现相应的抽象产品类，再增加一个具体实现工厂就好了。</p>

<p>不过它的缺点是在产品族也就是想新增解析需求的时候扩展性不好，比如后来想增加对搜索关键词后的首页文章内容进行统计，以便查看匹配度时。就需要增加一个产品族即抽象产品模块，需要修改每个工厂的代码。</p>

<p>作者：<a href="http://tianweili.github.io/">李天炜</a></p>

<p>原文链接：<a href="http://tianweili.github.io/blog/2015/03/11/abstract-factory-pattern/">http://tianweili.github.io/blog/2015/03/11/abstract-factory-pattern/</a></p>

<p>转载请注明作者和文章出处，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[工厂方法模式]]></title>
    <link href="http://tianweili.github.io/blog/2015/03/09/factory-method-pattern/"/>
    <updated>2015-03-09T21:07:29+08:00</updated>
    <id>http://tianweili.github.io/blog/2015/03/09/factory-method-pattern</id>
    <content type="html"><![CDATA[<p>工厂方法模式是简单工厂模式的衍生，核心工厂类不再负责具体产品的创建，而是一个抽象工厂的角色，仅仅定义子类工厂必须实现的接口。这样进一步抽象的好处是可以使系统在不修改具体工厂类的方式下引进新的产品。</p>

<!--more-->


<p>原文链接：</p>

<p><a href="http://tianweili.github.io/blog/2015/03/09/factory-method-pattern/">http://tianweili.github.io/blog/2015/03/09/factory-method-pattern/</a></p>

<h2>介绍</h2>

<p>工厂方法模式定义：Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses。<strong>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</strong></p>

<p>工厂方法模式的对简单工厂模式进行了抽象。有一个抽象的Factory类（可以是抽象类和接口），这个类将不再负责具体的产品生产，而是只制定一些规范，具体的生产工作由其子类去完成。在这个模式中，工厂类和产品类往往可以依次对应。即一个抽象工厂对应一个抽象产品，一个具体工厂对应一个具体产品，这个具体的工厂就负责生产对应的产品。</p>

<p><strong>工厂方法模式的核心和关键点是对工厂也进行了抽象。</strong></p>

<h2>UML类图</h2>

<p>工厂方法模式的UML类图如下所示：</p>

<p><img src="http://7u2i08.com1.z0.glb.clouddn.com/design-pattern/factory-method-uml.png"></p>

<p>在上面的UML图中主要包含了四中角色：</p>

<p>抽象工厂（Abstract Factory）角色</p>

<p>抽象工厂角色是工厂方法模式的核心，主要定义了具体工厂子类必须要实现的接口，并且所有创建对象的工厂类都必须实现该方法，与应用程序无关。</p>

<p>具体工厂（Concrete Factory）角色</p>

<p>这是实现抽象工厂的具体工厂类，包含与应用程序密切相关的逻辑，要受到应用程序的调用以创建产品对象。</p>

<p>抽象产品（Abstract Product）角色</p>

<p>具体产品对象的共同父类，由它来定义所有产品的共同接口。</p>

<p>具体产品（Concrete Product）角色</p>

<p>具体产品是简单工厂模式的创建目标，所有创建的对象都是某个具体产品类的实例。</p>

<h2>代码示例</h2>

<pre><code class="java">public interface Product {
    public void method();
}
public class ProductA implements Product{
    @Override
    public void method() {
        System.out.println("ProductA Method ...");
    }
}
public class ProductB implements Product{
    @Override
    public void method() {
        System.out.println("ProductB Method ...");
    }
}
public interface Factory {
    public Product create();
}
public class FactoryA implements Factory{
    @Override
    public Product create() {
        return new ProductA();
    }
}
public class FactoryB implements Factory{
    @Override
    public Product create() {
        return new ProductB();
    }
}
public class Client {
    public static void main(String[] args) {
        Factory factory = new FactoryA();
        Product product = factory.create();
        product.method();

        factory = new FactoryB();
        product = factory.create();
        product.method();
    }
}
</code></pre>

<p>运行结果：</p>

<pre><code>ProductA Method ...
ProductB Method ...
</code></pre>

<h2>与简单工厂模式的区别</h2>

<p>工厂方法模式是简单功能工厂模式的衍生，它将工厂也抽象出来，定义了一个抽象工厂，将产品对象的实例化过程推到了下面的各个子类工厂，而且子类工厂与产品也是一一对应的。这是两者最大的区别。</p>

<p>工厂方法模式多了一个抽象工厂。</p>

<p>工厂方法模式支持多态。</p>

<h2>优点</h2>

<p>解决了许多简单工厂模式中出现的问题。</p>

<p>完全符合”开闭原则”，具有可扩展性。</p>

<p>更为复杂的层次结构，可以应付产品结果更为复杂的场合。</p>

<p>工厂方法模式是典型的解耦框架。高层模块只需要知道产品的抽象类，其它实现类都不需要关心，符合迪米特法则。只依赖产品的抽象，符合依赖倒置原则。使用产品子类替换产品父类，符合里氏替换原则。</p>

<h2>缺点</h2>

<p>抽象出了一个抽象工厂，添加了具体工厂子类，会提高系统的复杂度。所以对于一些复杂的创建过程使用工厂方法模式才比较合适。</p>

<h2>适用场景</h2>

<p>工厂方法模式是使用非常频繁的设计模式之一，在系统设计中几乎随处可见。简单工厂模式、工厂方法模式、抽象工厂模式这三个设计模式都有一些类似的特性，所以在适用场景上也都是类似的。</p>

<p>首先，作为一个创建型模式，在任何需要生成复杂对象的地方都可以使用工厂方法模式。但是要注意对于一些生成对象简单，特别是只需要通过new来生成对象的地方，就不需要使用工厂方法模式了。因为如果使用工厂方法模式，就需要引入一个工厂类，会增加系统的复杂度。</p>

<p>另外，在需要一个可扩展性强的系统设计中，可以考虑使用工厂方法模式。比如产品对象预期可能会经常造成增加或删减等，使用工厂方法模式来设计可以使系统更加灵活。</p>

<h2>应用实例</h2>

<h3>Java中的线程同步安全容器</h3>

<p>Java中的很多集合容器比如ArrayList等都不是线程安全的，在多线程并发情况下可能出现线程安全问题。</p>

<p>我们可以使用<code>Collections.synchronizedList(new ArrayList())</code>获得一个线程安全的容器。这个就用到了工厂方法模式。</p>

<h3>Collection中的iterator方法</h3>

<p><code>java.util.Collection</code>接口中的<code>iterator()</code>方法就是一个工厂方法。对于iterator方法来说Collection就是一个根抽象工厂，下面还有List等接口作为抽象工厂，再往下有ArrayList等具体工厂。
<code>java.util.Iterator</code>接口是根抽象产品，下面有ListIterator等抽象产品，还有ArrayListIterator等作为具体产品。</p>

<p>获得产品代码：</p>

<pre><code class="java">Collection c = new ArrayList();
Iterator i = c.iterator();
</code></pre>

<p>基本的UML类图如下所示：</p>

<p><img src="http://7u2i08.com1.z0.glb.clouddn.com/design-pattern/collection-iterator-uml.png"></p>

<h3>JDBC数据库开发</h3>

<p>在使用JDBC进行数据库开发时，如果数据库由MySQL改为Oracle或其他，则只需要改一下数据库驱动名称就可以，其他都不用修改（前提是使用的都是标准SQL语句）。或者在Hibernate框架中，更换数据库方言也是类似道理。</p>

<h3>连接邮件服务器框架</h3>

<p>如果需要设计一个连接邮件服务器的框架，那么就要考虑到连接邮件服务器有几种方式：POP3、SMTP、HTTP。就可以定义一个连接邮件服务器接口，在此接口中定义一些对邮件操作的接口方法，把这三种连接方式封装成产品类，实现接口中定义的抽象方法。再定义抽象工厂和具体工厂，当选择不同的工厂时，对应到产生相应的连接邮件产品对象。采用这种工厂方法模式的设计，就可以做到良好的扩展性。比如某些邮件服务器提供了WebService接口，只需要增加一个产品类和工厂类就可以了，而不需要修改原来代码。</p>

<h3>网页爬虫解析</h3>

<p>在一个项目中，需要实现的需求是这样的：公司有很多站点，需要带着指定的一些关键字去网站上爬取广告、文章、产品等信息解析下来，而不同的站点风格各异，爬取和解析的方式也各不相同。</p>

<p>所以这里就用到了工厂方法模式，抽象出一个抽象产品，定义公共接口，爬取解析某个站点就封装成一个产品对象。再抽象出抽象工厂，使一些具体工厂实现抽象工厂定义的调用产品接口，每个具体工厂对应一个产品。</p>

<p>作者：<a href="http://tianweili.github.io/">李天炜</a></p>

<p>原文链接：<a href="http://tianweili.github.io/blog/2015/03/09/factory-method-pattern/">http://tianweili.github.io/blog/2015/03/09/factory-method-pattern/</a></p>

<p>转载请注明作者和文章出处，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[简单工厂模式]]></title>
    <link href="http://tianweili.github.io/blog/2015/03/08/simple-factory-pattern/"/>
    <updated>2015-03-08T19:49:20+08:00</updated>
    <id>http://tianweili.github.io/blog/2015/03/08/simple-factory-pattern</id>
    <content type="html"><![CDATA[<p>简单工厂模式就是工厂对象根据传入的参数，动态的决定创建哪一种产品类的实例，而这些产品类继承自一个父类或一个接口。</p>

<!--more-->


<p>原文链接：</p>

<p><a href="http://tianweili.github.io/blog/2015/03/08/simple-factory-pattern/">http://tianweili.github.io/blog/2015/03/08/simple-factory-pattern/</a></p>

<h2>介绍</h2>

<p>简单工厂模式属于创建型模式，又叫做静态工厂方法(static factory method)。但是它并没有归为23种GOF设计模式其中。</p>

<p>简单工厂模式是<strong>由工厂对象来决定创建哪一种产品类的实例</strong>。</p>

<p>简单说就是工厂对象根据传入的参数，动态的决定创建哪一种产品类的实例，而这些产品类继承自一个父类或一个接口。</p>

<h2>UML类图</h2>

<p>简单工厂模式的一个基本的UML类图如下所示：</p>

<p><img src="http://7u2i08.com1.z0.glb.clouddn.com/design-pattern/simple-factory-uml.png"></p>

<p>在这个UML类图中包含以下角色：</p>

<p>工厂（Factory）</p>

<p>这是简单工厂模式的核心，由它来负责实现创建所有实例的逻辑。工厂对象用来被外界调用，根据传入的参数来决定创建哪一个产品对象。</p>

<p>抽象产品（Abstract Product）</p>

<p>抽象类或接口。是所有具体产品对象的父类，由它来定义所有具体产品的公共接口。</p>

<p>具体产品（Concrete Product）</p>

<p>具体产品是简单工厂模式的创建目标，所有创建的对象都是某个具体产品类的实例。</p>

<h2>代码示例</h2>

<pre><code class="java">public interface Product {
    public void function();
}
public class ProductA implements Product{
    @Override
    public void function() {
        System.out.println("ProductA function ...");
    }
}
public class ProductB implements Product{
    @Override
    public void function() {
        System.out.println("ProductB function ...");
    }
}
public class Factory {
    public Product create(String productName) {
        if (productName == null || "".equals(productName)) {
            return null;
        }
        if ("productA".equals(productName)) {
            return new ProductA();
        } else if ("productB".equals(productName)) {
            return new ProductB();
        }
        return null;
    }
}
public class Main {
    public static void main(String[] args) {
        Factory factory = new Factory();
        Product product1 = factory.create("productA");
        Product product2 = factory.create("productB");
        product1.function();
        product2.function();
    }
}
</code></pre>

<p>输出结果：</p>

<pre><code>ProductA function ...
ProductB function ...
</code></pre>

<h2>优点</h2>

<p>客户类和工厂类分开。消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。</p>

<p>外界不用关注对象创建逻辑，产品对象具体的创建过程由工厂来实现。外界直接给定信息来决定创建哪个产品对象。</p>

<p>明确了各自的职责，有利于整个软件体系结构的优化。</p>

<h2>缺点</h2>

<p>违反高内聚责任分配原则，将所有的创建逻辑都集中在了工厂类身上。</p>

<p>如果需要添加新的产品类，则需要修改工厂类。</p>

<p>当产品类不断增多，工厂类对产品类型的判断条件过多交织在了一起，会造成逻辑过于复杂，对系统的扩展和维护不利。</p>

<h2>使用场景</h2>

<p>工厂类创建的产品对象比较少。</p>

<p>外界只需要传入工厂类参数来获得产品对象，对于产品对象的创建过程不关心。</p>

<p>简单工厂模式很容易违反高内聚责任分配原则，所以只是在一些很简单的情况下使用。</p>

<h2>应用实例</h2>

<h3>附件的解压</h3>

<p>在工作中，有一个项目模块中要求的功能是：登录邮箱，获取邮件，然后抓取邮件中的附件，下载下来，如果是压缩包，则进行解压，然后进行相应处理。在解压时就用到了简单工厂模式。附件压缩包格式不一，有zip,rar等格式，则把每一种格式的解压和处理都放到一个产品对象中，然后使用一个工厂类来决定创建哪一个产品进行相应的处理。</p>

<p>由于这个压缩包解压方式并不多，判断逻辑并不太复杂，所以也没必要用工厂方法模式，增加代码复杂度。</p>

<p>作者：<a href="http://tianweili.github.io/">李天炜</a></p>

<p>原文链接：<a href="http://tianweili.github.io/blog/2015/03/08/simple-factory-pattern/">http://tianweili.github.io/blog/2015/03/08/simple-factory-pattern/</a></p>

<p>转载请注明作者和文章出处，谢谢。</p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | 李天炜]]></title>
  <link href="http://tianweili.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://tianweili.github.io/"/>
  <updated>2015-03-10T19:23:06+08:00</updated>
  <id>http://tianweili.github.io/</id>
  <author>
    <name><![CDATA[李天炜 litianwei2013[AT]gmail.com]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Log4j的配置与使用详解]]></title>
    <link href="http://tianweili.github.io/blog/2015/03/03/log4j/"/>
    <updated>2015-03-03T19:38:49+08:00</updated>
    <id>http://tianweili.github.io/blog/2015/03/03/log4j</id>
    <content type="html"><![CDATA[<p>Log4j是Apache的一个开放源代码项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件、甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。</p>

<!--more-->


<p>原文链接：</p>

<p><a href="http://tianweili.github.io/blog/2015/03/03/log4j/">http://tianweili.github.io/blog/2015/03/03/log4j/</a></p>

<h2>简介</h2>

<p>Log4j由三个重要的组件构成：<strong>日志信息的优先级，日志信息的输出目的地，日志信息的输出格式</strong>。日志信息的优先级从高到低有<code>ERROR</code>、<code>WARN</code>、<code>INFO</code>、<code>DEBUG</code>，分别用来指定这条日志信息的重要程度；日志信息的输出目的地指定了日志将打印到控制台还是文件中；而输出格式则控制了日志信息的显示内容。</p>

<h2>配置文件</h2>

<p>其实也可以完全不使用配置文件，而是在代码中配置Log4j环境。但是，使用配置文件将使您的应用程序更加灵活。</p>

<p>Log4j支持两种配置文件格式，一种是<code>XML格式</code>的文件，一种是<code>properties格式</code>的文件。以下介绍使用properties格式做为配置文件的方法：</p>

<p>基本的格式如下：</p>

<pre><code class="properties">#配置根Logger
log4j.rootLogger  =   [ level ]   ,  appenderName1 ,  appenderName2 ,  …

#配置日志信息输出目的地Appender
log4j.appender.appenderName  =  fully.qualified.name.of.appender.class 
　　log4j.appender.appenderName.option1  =  value1 
　　… 
　　log4j.appender.appenderName.optionN  =  valueN 

#配置日志信息的格式（布局）
log4j.appender.appenderName.layout  =  fully.qualified.name.of.layout.class 
　　log4j.appender.appenderName.layout.option1  =  value1 
　　… 
　　log4j.appender.appenderName.layout.optionN  =  valueN 
</code></pre>

<h3>1.配置根Logger</h3>

<p>语法为：</p>

<pre><code>log4j.rootLogger = [ level ] , appenderName, appenderName, … 
</code></pre>

<p>其中，level 是日志记录的优先级，分为<code>OFF</code>、<code>FATAL</code>、<code>ERROR</code>、<code>WARN</code>、<code>INFO</code>、<code>DEBUG</code>、<code>ALL</code>或者你定义的级别。Log4j建议只使用四个级别，优先级从高到低分别是<code>ERROR</code>、<code>WARN</code>、<code>INFO</code>、<code>DEBUG</code>。通过在这里定义的级别，您可以控制到应用程序中相应级别的日志信息的开关。比如在这里定义了INFO级别，则应用程序中所有DEBUG级别的日志信息将不被打印出来。</p>

<p>appenderName就是指定日志信息输出到哪个地方。您可以同时指定多个输出目的地。</p>

<h3>2.配置日志信息输出目的地Appender</h3>

<p>Log4j提供的appender有以下几种：</p>

<ul>
<li><code>org.apache.log4j.ConsoleAppender</code>（控制台），</li>
<li><code>org.apache.log4j.FileAppender</code>（文件），</li>
<li><code>org.apache.log4j.DailyRollingFileAppender</code>（每天产生一个日志文件），</li>
<li><code>org.apache.log4j.RollingFileAppender</code>（文件大小到达指定尺寸的时候产生一个新的文件），</li>
<li><code>org.apache.log4j.WriterAppender</code>（将日志信息以流格式发送到任意指定的地方）</li>
</ul>


<p>其中，每种appender可以定义的option1如下：</p>

<h4>(1).ConsoleAppender 选项</h4>

<ul>
<li><code>Threshold=WARN</code>:指定日志消息的输出最低层次。</li>
<li><code>ImmediateFlush=true</code>:默认值是true,意谓着所有的消息都会被立即输出。</li>
<li><code>Target=System.err</code>:默认情况下是：System.out,指定输出控制台</li>
</ul>


<h4>(2).FileAppender 选项</h4>

<ul>
<li><code>Threshold=WARN</code>:指定日志消息的输出最低层次。</li>
<li><code>ImmediateFlush=true</code>:默认值是true,意谓着所有的消息都会被立即输出。</li>
<li><code>File=mylog.txt</code>:指定消息输出到mylog.txt文件。</li>
<li><code>Append=false</code>:默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。</li>
</ul>


<h4>(3).DailyRollingFileAppender 选项</h4>

<ul>
<li><code>Threshold=WARN</code>:指定日志消息的输出最低层次。</li>
<li><code>ImmediateFlush=true</code>:默认值是true,意谓着所有的消息都会被立即输出。</li>
<li><code>File=mylog.txt</code>:指定消息输出到mylog.txt文件。</li>
<li><code>Append=false</code>:默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。</li>
<li><code>DatePattern='.'yyyy-ww</code>:每周滚动一次文件，即每周产生一个新的文件。当然也可以指定按月、周、天、时和分。即对应的格式如下：

<ul>
<li><code>'.'yyyy-MM</code>: 每月</li>
<li><code>'.'yyyy-ww</code>: 每周</li>
<li><code>'.'yyyy-MM-dd</code>: 每天</li>
<li><code>'.'yyyy-MM-dd-a</code>: 每天两次</li>
<li><code>'.'yyyy-MM-dd-HH</code>: 每小时</li>
<li><code>'.'yyyy-MM-dd-HH-mm</code>: 每分钟</li>
</ul>
</li>
</ul>


<h4>(4).RollingFileAppender 选项</h4>

<ul>
<li><code>Threshold=WARN</code>:指定日志消息的输出最低层次。</li>
<li><code>ImmediateFlush=true</code>:默认值是true,意谓着所有的消息都会被立即输出。</li>
<li><code>File=mylog.txt</code>:指定消息输出到mylog.txt文件。</li>
<li><code>Append=false</code>:默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。</li>
<li><code>MaxFileSize=100KB</code>: 后缀可以是KB, MB 或者是 GB. 在日志文件到达该大小时，将会自动滚动，即将原来的内容移到mylog.log.1文件。</li>
<li><code>MaxBackupIndex=2</code>:指定可以产生的滚动文件的最大数。</li>
</ul>


<h3>3.配置日志信息的输出格式</h3>

<p>Log4j提供的layout有以下几种：</p>

<ul>
<li><code>org.apache.log4j.HTMLLayout</code>（以HTML表格形式布局），</li>
<li><code>org.apache.log4j.PatternLayout</code>（可以灵活地指定布局模式），</li>
<li><code>org.apache.log4j.SimpleLayout</code>（包含日志信息的级别和信息字符串），</li>
<li><code>org.apache.log4j.TTCCLayout</code>（包含日志产生的时间、线程、类别等等信息）</li>
</ul>


<h3>4.输出格式设置</h3>

<p>在配置文件中可以通过<code>log4j.appender.A1.layout.ConversionPattern</code>设置日志输出格式。</p>

<p>参数：</p>

<ul>
<li><code>%p</code>: 输出日志信息优先级，即DEBUG，INFO，WARN，ERROR，FATAL,</li>
<li><code>%d</code>: 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921</li>
<li><code>%r</code>: 输出自应用启动到输出该log信息耗费的毫秒数</li>
<li><code>%c</code>: 输出日志信息所属的类目，通常就是所在类的全名</li>
<li><code>%t</code>: 输出产生该日志事件的线程名</li>
<li><code>%l</code>: 输出日志事件的发生位置，相当于%C.%M(%F:%L)的组合,包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10)</li>
<li><code>%x</code>: 输出和当前线程相关联的NDC(嵌套诊断环境),尤其用到像java servlets这样的多客户多线程的应用中。</li>
<li><code>%%</code>: 输出一个”%”字符</li>
<li><code>%F</code>: 输出日志消息产生时所在的文件名称</li>
<li><code>%L</code>: 输出代码中的行号</li>
<li><code>%m</code>: 输出代码中指定的消息,产生的日志具体信息</li>
<li><code>%n</code>: 输出一个回车换行符，Windows平台为”\r\n”，Unix平台为”\n”输出日志信息换行</li>
</ul>


<p>可以在%与模式字符之间加上修饰符来控制其最小宽度、最大宽度、和文本的对齐方式。如：</p>

<ul>
<li><code>%20c</code>：指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，默认的情况下右对齐。</li>
<li><code>%-20c</code>:指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，”-”号指定左对齐。</li>
<li><code>%.30c</code>:指定输出category的名称，最大的宽度是30，如果category的名称大于30的话，就会将左边多出的字符截掉，但小于30的话也不会有空格。</li>
<li><code>%20.30c</code>:如果category的名称小于20就补空格，并且右对齐，如果其名称长于30字符，就从左边交远销出的字符截掉。</li>
</ul>


<h2>在程序中的使用</h2>

<p>在程序中使用Log4j之前，首先要将<code>commons-logging.jar</code>和<code>logging-log4j-1.2.9.jar</code>导入到classpath中，并将log4j.properties放于src根目录中。接下来就可以使用了。</p>

<h3>1.得到记录器</h3>

<p>使用Log4j，第一步就是获取日志记录器，这个记录器将负责控制日志信息。其语法为：</p>

<pre><code class="java">public static Logger getLogger(String name);
</code></pre>

<p>通过指定的名字获得记录器，如果必要的话，则为这个名字创建一个新的记录器。Name一般取本类的名字，比如：</p>

<pre><code class="java">static Logger logger = Logger.getLogger ( ClassName.class.getName () ) ; 
</code></pre>

<p><strong>注：推荐使用commons-logging结合log4j进行日志记录。</strong></p>

<pre><code class="java">private static Log logger = LogFactory.getLog(Yourclass.class); 
</code></pre>

<h3>2.插入记录信息（格式化日志信息）</h3>

<p>当上两个必要步骤执行完毕，您就可以轻松地使用不同优先级别的日志记录语句插入到您想记录日志的任何地方，其语法如下：</p>

<pre><code class="java">Logger.debug ( Object message ) ; 
Logger.info ( Object message ) ; 
Logger.warn ( Object message ) ; 
Logger.error ( Object message ) ; 
</code></pre>

<h2>Log4j配置范例</h2>

<p>LOG4J的配置之简单使它遍及于越来越多的应用中了：Log4J配置文件实现了输出到控制台、文件、回滚文件、发送日志邮件、输出到数据库日志表、自定义标签等全套功能。择其一二使用就够用了。</p>

<pre><code class="properties">log4j.rootLogger=DEBUG,CONSOLE,file,ROLLING_FILE,SOCKET,MAIL,DATABASE,im

# 应用于控制台
log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
log4j.appender.Threshold=DEBUG
log4j.appender.CONSOLE.Target=System.out
log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout
log4j.appender.CONSOLE.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n
#log4j.appender.CONSOLE.layout.ConversionPattern=[start]%d{DATE}[DATE]%n%p[PRIORITY]%n%x[NDC]%n%t[thread] n%c[CATEGORY]%n%m[MESSAGE]%n%n


#应用于文件
log4j.appender.file=org.apache.log4j.DailyRollingFileAppender
log4j.appender.file.DatePattern='.'yyyy-MM-dd
log4j.appender.file.File=/logs/ecps.log
log4j.appender.file.layout=org.apache.log4j.PatternLayout 
log4j.appender.file.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss} %p [%c]: %m%n

# 应用于文件回滚
log4j.appender.ROLLING_FILE=org.apache.log4j.RollingFileAppender
log4j.appender.ROLLING_FILE.Threshold=ERROR
log4j.appender.ROLLING_FILE.File=rolling.log //文件位置,也可以用变量${java.home}、rolling.log
log4j.appender.ROLLING_FILE.Append=true //true:添加 false:覆盖
log4j.appender.ROLLING_FILE.MaxFileSize=10KB //文件最大尺寸
log4j.appender.ROLLING_FILE.MaxBackupIndex=1 //备份数
log4j.appender.ROLLING_FILE.layout=org.apache.log4j.PatternLayout
log4j.appender.ROLLING_FILE.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n

#应用于socket
log4j.appender.SOCKET=org.apache.log4j.RollingFileAppender
log4j.appender.SOCKET.RemoteHost=localhost
log4j.appender.SOCKET.Port=5001
log4j.appender.SOCKET.LocationInfo=true
# Set up for Log Facter 5
log4j.appender.SOCKET.layout=org.apache.log4j.PatternLayout
log4j.appender.SOCET.layout.ConversionPattern=[start]%d{DATE}[DATE]%n%p[PRIORITY]%n%x[NDC]%n%t[thread]%n%c[CATEGORY]%n%m[MESSAGE]%n%n

# Log Factor 5 Appender
log4j.appender.LF5_APPENDER=org.apache.log4j.lf5.LF5Appender
log4j.appender.LF5_APPENDER.MaxNumberOfRecords=2000


# 发送日志给邮件

log4j.appender.MAIL=org.apache.log4j.net.SMTPAppender
log4j.appender.MAIL.Threshold=ERROR
log4j.appender.MAIL.BufferSize=10
log4j.appender.MAIL.From=123@qq.com
log4j.appender.MAIL.SMTPHost=smtp.qq.com
log4j.appender.MAIL.SMTPUsername=123
log4j.appender.MAIL.SMTPPassword=***
log4j.appender.MAIL.SMTPDebug=false
log4j.appender.MAIL.Subject=Log4JErrorMessage
log4j.appender.MAIL.To=123@qq.com
log4j.appender.MAIL.layout=org.apache.log4j.PatternLayout
log4j.appender.MAIL.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss} [%t] %-5p %c %x -- %m%n


# 用于数据库
log4j.appender.DATABASE=org.apache.log4j.jdbc.JDBCAppender
log4j.appender.DATABASE.URL=jdbc:mysql://localhost:3306/test
log4j.appender.DATABASE.driver=com.mysql.jdbc.Driver
log4j.appender.DATABASE.user=root
log4j.appender.DATABASE.password=
log4j.appender.DATABASE.sql=INSERT INTO LOG4J (Message) VALUES (’[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n’)
log4j.appender.DATABASE.layout=org.apache.log4j.PatternLayout
log4j.appender.DATABASE.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n

#自定义Appender
log4j.appender.im = net.cybercorlin.util.logger.appender.IMAppender
log4j.appender.im.host = mail.cybercorlin.net
log4j.appender.im.username = username
log4j.appender.im.password = password
log4j.appender.im.recipient = corlin@cybercorlin.net
log4j.appender.im.layout=org.apache.log4j.PatternLayout
log4j.appender.im.layout.ConversionPattern =[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n
</code></pre>

<h2>使用Log4J监控系统日志邮件警报</h2>

<p>在系统上线后，有时候遇到系统故障，这时候就可以登录服务器查看系统日志来排查问题。但是需要登录服务器，下载查找相关异常日志比较麻烦。而且没有监控的话，也无法实时了解到系统是否正常运行。那么有没有一种好办法将系统异常信息实时反馈给相关人员呢？</p>

<p>下面讲的就是借助Log4J来记录程序运行日志，当一旦发现系统异常或者自己定义的其他一些情况发生时，及时通过邮件形式发送给相关负责人，并附上相关的系统日志信息，这样负责人就可以实时便捷的监控到系统的状态和相关异常信息。</p>

<h3>优点</h3>

<p>采用这种方式的优点有：</p>

<ul>
<li>实时性。不用定期或不定期的登陆系统查看是否正常运行。</li>
<li>及时性。一旦系统异常，就会通知。</li>
<li>便捷性。邮件里附上异常日志，不用登陆系统下载日志查看。</li>
</ul>


<h3>环境</h3>

<p>导入依赖jar包：</p>

<p>1.log4j-1.2.17.jar</p>

<p><a href="http://logging.apache.org/log4j/1.2/">官网下载地址</a></p>

<p>目前log4j最新版是1.2.17。低版本的log4j无法实现邮件发送功能，因为版本低于log4j-1.2.14.jar的不支持SMTP认证。</p>

<p>发送邮件的一个重要的类是SMTPAppender，在1.2.8的版本中，SMTPAppender没有SMTPUsername和SMTPPassword属性。这两个属性分别是登录SMTP服务器发送认证的用户名和密码。</p>

<p>2.mail-1.4.jar</p>

<p>发送邮件当然需要用到JavaMail包啦。</p>

<p>3.activation-1.1.jar</p>

<h3>配置</h3>

<p>配置log4j.properties文件，如下：</p>

<pre><code> 1 log4j.rootLogger=DEBUG, MAIL
 2 
 3 log4j.appender.MAIL=org.apache.log4j.net.SMTPAppender
 4 log4j.appender.MAIL.Threshold=ERROR
 5 log4j.appender.MAIL.BufferSize=10
 6 log4j.appender.MAIL.From=123@qq.com
 7 log4j.appender.MAIL.SMTPHost=smtp.qq.com
 8 log4j.appender.MAIL.SMTPUsername=123
 9 log4j.appender.MAIL.SMTPPassword=***
10 log4j.appender.MAIL.SMTPDebug=false
11 log4j.appender.MAIL.Subject=Log4JErrorMessage
12 log4j.appender.MAIL.To=123@qq.com
13 log4j.appender.MAIL.layout=org.apache.log4j.PatternLayout
14 log4j.appender.MAIL.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss} [%t] %-5p %c %x -- %m%n
</code></pre>

<p>每行配置详解：</p>

<ul>
<li>3.log4j的邮件发送appender，如果有必要你可以写自己的appender。</li>
<li>4.发送邮件的门槛，仅当等于或高于ERROR级别时，邮件才被发送。</li>
<li>5.缓存文件大小，日志达到10k时发送Email。</li>
<li>6.发送邮件的邮箱帐号。</li>
<li>7.SMTP邮件发送服务器地址。</li>
<li>8.SMTP发送认证的帐号名。</li>
<li>9.SMTP发送认证帐号的密码。</li>
<li>10.是否打印调试信息，如果选true，则会输出和SMTP之间的握手等详细信息</li>
<li>11.邮件主题。</li>
<li>12.发送到什么邮箱，如果要发送给多个邮箱，则用逗号分隔。</li>
</ul>


<p>如果需要抄送给某人，则添加如下配置：</p>

<pre><code>log4j.appender.MAIL.Bcc=xxx@xxx.xxx
</code></pre>

<p>想让邮件内容日志以HTML格式来输出，则配置：</p>

<pre><code>log4j.appender.MAIL.layout=org.apache.log4j.HTMLLayout
</code></pre>

<p>输出到邮件中显示如下图：</p>

<p><img src="http://7u2i08.com1.z0.glb.clouddn.com/log4j/log4j_mail_output.png"></p>

<p>作者：<a href="http://tianweili.github.io/">李天炜</a></p>

<p>原文链接：<a href="http://tianweili.github.io/blog/2015/03/03/log4j/">http://tianweili.github.io/blog/2015/03/03/log4j/</a></p>

<p>转载请注明作者和文章出处，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用JXL组件操作Excel和导出文件]]></title>
    <link href="http://tianweili.github.io/blog/2015/01/29/use-jxl-produce-excel/"/>
    <updated>2015-01-29T16:29:57+08:00</updated>
    <id>http://tianweili.github.io/blog/2015/01/29/use-jxl-produce-excel</id>
    <content type="html"><![CDATA[<p>这段时间参与的项目要求做几张Excel报表，由于项目框架使用了jxl组件，所以把jxl组件的详细用法归纳总结一下。本文主要讲述了以下内容：</p>

<ul>
<li>JXL及相关工具简介</li>
<li>如何安装JXL</li>
<li>JXL的基本操作

<ul>
<li>创建文件</li>
<li>单元格操作

<ul>
<li>合并单元格</li>
<li>行高和列宽</li>
</ul>
</li>
<li>数据格式化

<ul>
<li>字符串格式化</li>
<li>对齐方式</li>
</ul>
</li>
<li>读取文件</li>
<li>修改文件</li>
</ul>
</li>
<li>导出文件实例</li>
</ul>


<!--more-->


<p>原文链接：<a href="http://tianweili.github.io/blog/2015/01/29/use-jxl-produce-excel/">http://tianweili.github.io/blog/2015/01/29/use-jxl-produce-excel/</a></p>

<h2>简介</h2>

<p>jxl是一个韩国人写的java操作excel的工具, 在开源世界中，有两套比较有影响的API可供使用，一个是POI，一个是jExcelAPI。其中jExcelAPI功能相对POI比较弱一点。但jExcelAPI对中文支持非常好，API是纯Java的，并不依赖Windows系统，即使运行在Linux下，它同样能够正确的处理Excel文件。另外需要说明的是，这套API对图形和图表的支持很有限，而且仅仅识别PNG格式。</p>

<h2>搭建环境</h2>

<p>网上下载jxl.jar包，然后导入工程项目lib中，即可使用。</p>

<h2>基本操作</h2>

<h3>1、创建文件</h3>

<p>以下实例是生成一个名为“test.xls”的Excel文件，其中第一个工作表被命名为“第一页”。编译执行后，会产生一个Excel文件。</p>

<pre><code class="java CreateExcel.java">// 生成Excel的类 
import java.io.File;

import jxl.Workbook;
import jxl.write.Label;
import jxl.write.WritableSheet;
import jxl.write.WritableWorkbook;

public class CreateExcel {
    public static void main(String args[]) {
        try {
            // 打开文件
            WritableWorkbook book = Workbook.createWorkbook(new File("c:/test.xls"));
            // 生成名为“第一页”的工作表，参数0表示这是第一页
            WritableSheet sheet = book.createSheet(" 第一页 ", 0);
            // 在Label对象的构造子中指名单元格位置是第一列第一行(0,0)
            // 以及单元格内容为test
            Label label = new Label(0, 0, " test ");
            // 将定义好的单元格添加到工作表中
            sheet.addCell(label);

            // 生成一个保存数字的单元格，必须使用Number的完整包路径，否则有语法歧义。
            //单元格位置是第二列，第一行，值为123.456
            jxl.write.Number number = new jxl.write.Number(1, 0, 123.456);
            sheet.addCell(number);

            // 写入数据并关闭文件
            book.write();
            book.close();
        } catch (Exception e) {
            System.out.println(e);
        }
    }
}
</code></pre>

<h3>2、单元格操作</h3>

<p>Excel中很重要的一部分是对单元格的操作，比如行高、列宽、单元格合并等，所幸jExcelAPI提供了这些支持。这些操作相对比较简单，下面只介绍一下相关的API。</p>

<h4>合并单元格</h4>

<p>合并既可以是横向的，也可以是纵向的。合并后的单元格不能再次进行合并，否则会触发异常。</p>

<pre><code class="java">// 方法作用是从(m,n)到(p,q)的单元格全部合并
WritableSheet.mergeCells( int m, int n, int p, int q);

// 合并第1列第1行到第3列第4行的所有单元格
sheet.mergeCells(0, 0, 2, 3);

// 先合并单元格，再添加内容。并且定义的列行方位在合并的单元格第一个列行方位，否则添加不上内容，如下所示：
Label label = new Label(0, 0, " 测试 ");
sheet.addCell(label);
</code></pre>

<h4>行高和列宽</h4>

<pre><code class="java">// 作用是指定第i+1行的高度
WritableSheet.setRowView( int i, int height);

// 将第一行的高度设为200
sheet.setRowView(0, 200);

// 作用是指定第i+1列的宽度
WritableSheet.setColumnView( int i, int width);

// 将第一列的宽度设为30
sheet.setColumnView(0, 30);
</code></pre>

<h3>3、数据格式化</h3>

<h4>字串格式化</h4>

<p>字符串的格式化涉及到的是字体、粗细、字号等元素，这些功能主要由WritableFont和WritableCellFormat类来负责。</p>

<p>WritableFont有非常丰富的构造子方法，供不同情况下使用，jExcelAPI的java-doc中有详细列表，这里不再列出。</p>

<p>WritableCellFormat类非常重要，通过它可以指定单元格的各种属性，后面的单元格格式化中会有更多描述。</p>

<pre><code class="java">//字体样式：宋体；11号；粗体
WritableFont font1 = new WritableFont(WritableFont.createFont("宋体"), 11, WritableFont.BOLD);
WritableCellFormat format1 = new  WritableCellFormat(font1);
Label label = new  Label( 0 , 0 , "test", format1);
</code></pre>

<h4>对齐方式</h4>

<p>在WritableCellFormat类中，还有一个很重要的方法是指定数据的对齐方式，比如针对我们上面的实例，可以指定：</p>

<pre><code class="java">// 把水平对齐方式指定为居中 
format1.setAlignment(jxl.format.Alignment.CENTRE);
// 把垂直对齐方式指定为居中 
format1.setVerticalAlignment(jxl.format.VerticalAlignment.CENTRE);
</code></pre>

<h3>4、读取文件</h3>

<pre><code class="java ReadExcel.java">// 读取Excel的类 
import java.io.File;

import jxl.Cell;
import jxl.Sheet;
import jxl.Workbook;

public class ReadExcel {
    public static void main(String args[]) {
        try {
            Workbook book = Workbook.getWorkbook(new File("c:/test.xls"));
            // 获得第一个工作表对象
            Sheet sheet = book.getSheet(0);
            // 得到第一列第一行的单元格
            Cell cell = sheet.getCell(0, 0);
            String contents = cell.getContents();//得到单元格内容
            System.out.println(contents);
            book.close();
        } catch (Exception e) {
            System.out.println(e);
        }
    }
}
</code></pre>

<p>程序的输出结果是：test。</p>

<p>Cell接口的方法还可以获取单元格行、列位置，单元格是否隐藏等属性。具体的参考jxl的API。</p>

<h3>5、修改文件</h3>

<p>修改Excel文件除了打开文件的方式不同之外，其他与创建Excel是一样的。</p>

<pre><code class="java UpdateExcel.java">// 修改Excel的类 
import java.io.File;

import jxl.Workbook;
import jxl.write.Label;
import jxl.write.WritableSheet;
import jxl.write.WritableWorkbook;

public class UpdateExcel {
    public static void main(String args[]) {
        try {
            // 获得Excel文件
            Workbook wb = Workbook.getWorkbook(new File("c:/test.xls"));
            // 打开一个文件的副本，并且指定数据写回到原文件
            WritableWorkbook book = Workbook.createWorkbook(new File("c:/test.xls"), wb);

            //修改原工作表数据
            WritableSheet sheet1 = book.getSheet(0);
            sheet1.addCell(new Label(0, 0, "覆盖原来的test"));

            // 添加一个新工作表
            WritableSheet sheet2 = book.createSheet(" 第二页 ", 1);
            sheet2.addCell(new Label(0, 0, " 第二页的测试数据 "));

            book.write();
            book.close();
        } catch (Exception e) {
            System.out.println(e);
        }
    }
}
</code></pre>

<h2>导出文件</h2>

<p>附上一个导出文件例子。</p>

<pre><code class="javascript">$( function() {
    /** 报表导出按钮 */
    $( '#exportBtn' ).click( function() {
        if( !$( '#frm' ).validationEngine( 'validate' ) )
            return false;
        $( '#frm' )[ 0 ].action = '${ctx }/exportAction.do?m=exportExcel';
        $( '#frm' )[ 0 ].submit();
        $( this ).attr( 'disabled', true );
        window.setTimeout( function() {
            document.getElementById( 'exportBtn' ).disabled = false;
        }, 5000 );
    } );
} );
</code></pre>

<pre><code class="java">/** 根据浏览器类型，转换为当前浏览器支持的中文*/
String fileName = "Excel工作表";

/** header 浏览器key */
String userAgent = request.getHeader("USER-AGENT").toUpperCase();
if (userAgent != null &amp;&amp; userAgent.length() != 0 &amp;&amp; fileName != null &amp;&amp; fileName.length() != 0) {
    /** header IE */
    if ( -1 != userAgent.indexOf("MSIE") )
        fileName = URLEncoder.encode(fileName, "UTF-8");
    /** header Mozilla */
    else if ( -1 != userAgent.indexOf("MOZILLA") )
        fileName = new String(fileName.getBytes(), "ISO8859-1");
    /** header Safari */
    else if ( -1 != userAgent.indexOf("SAFARI") )
        fileName = new String( fileName.getBytes(), "ISO8859-1");
    /** header Opera */
    else if ( -1 != userAgent.indexOf("OPERA") )
        fileName = new String( fileName.getBytes(), "ISO8859-1");
    /** header 其它内核浏览器 */
    else
        fileName = new String( fileName.getBytes(), "ISO8859-1");
}

response.setCharacterEncoding("UTF-8");
response.setContentType("application/vnd.ms-excel");
response.setHeader("Content-disposition", new StringBuffer("attachment").append( ";filename=" ).append( fileName ).append(".xls").toString() );

WritableWorkbook book = Workbook.createWorkbook(response.getOutputStream());
WritableSheet sheet = book.createSheet("Excel工作表", 0);

//...

book.write();
book.close();
</code></pre>

<p>作者：<a href="http://tianweili.github.io/">李天炜</a></p>

<p>原文链接：<a href="http://tianweili.github.io/blog/2015/01/29/use-jxl-produce-excel/">http://tianweili.github.io/blog/2015/01/29/use-jxl-produce-excel/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中的Listener 监听器]]></title>
    <link href="http://tianweili.github.io/blog/2015/01/27/java-listener/"/>
    <updated>2015-01-27T15:36:14+08:00</updated>
    <id>http://tianweili.github.io/blog/2015/01/27/java-listener</id>
    <content type="html"><![CDATA[<p>本文介绍了Listener以下几个方面的内容：</p>

<ul>
<li>Listener的定义与作用</li>
<li>Listener的分类与使用

<ul>
<li>ServletContext监听</li>
<li>Session监听</li>
<li>Request监听</li>
</ul>
</li>
<li>Listener的应用实例

<ul>
<li>利用HttpSessionListener统计最多在线用户人数</li>
<li>Spring使用ContextLoaderListener加载ApplicationContext配置信息</li>
<li>Spring使用Log4jConfigListener配置Log4j日志</li>
<li>Spring使用IntrospectorCleanupListener清理缓存</li>
</ul>
</li>
</ul>


<!--more-->


<p>原文链接：<a href="http://tianweili.github.io/blog/2015/01/27/java-listener/">http://tianweili.github.io/blog/2015/01/27/java-listener/</a></p>

<p><a href="http://tianweili.github.io/blog/2015/01/26/java-filter/">之前写了一篇关于Filter的文章</a>，现在再来一篇Listener的，Filter和Listener在项目中是经常用到的，巧妙的使用可以达到事半功倍的效果。故把两者的用法总结一下。</p>

<h2>Listener的定义与作用</h2>

<p>监听器Listener就是在application,session,request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件。</p>

<p>Listener是Servlet的监听器，可以监听客户端的请求，服务端的操作等。</p>

<h2>Listener的分类与使用</h2>

<p>主要有以下三类：</p>

<h3>1、ServletContext监听</h3>

<p>ServletContextListener：用于对Servlet整个上下文进行监听（创建、销毁）。</p>

<pre><code class="java">//上下文初始化
public void contextInitialized(ServletContextEvent sce);
//上下文销毁
public void contextDestroyed(ServletContextEvent sce);
//ServletContextEvent事件：取得一个ServletContext（application）对象
public ServletContext getServletContext();
</code></pre>

<p>ServletContextAttributeListener：对Servlet上下文属性的监听（增删改属性）。</p>

<pre><code class="java">//增加属性
public void attributeAdded(ServletContextAttributeEvent scab);
//属性删除
public void attributeRemoved(ServletContextAttributeEvent scab);
//属性替换（第二次设置同一属性）
public void attributeRepalced(ServletContextAttributeEvent scab);

//ServletContextAttributeEvent事件：能取得设置属性的名称与内容
//得到属性名称
public String getName();
//取得属性的值
public Object getValue();
</code></pre>

<h3>2、Session监听</h3>

<p>Session属于http协议下的内容，接口位于javax.servlet.http.*包下。</p>

<p>HttpSessionListener接口：对Session的整体状态的监听。</p>

<pre><code class="java">//session创建
public void sessionCreated(HttpSessionEvent se);
//session销毁
public void sessionDestroyed(HttpSessionEvent se);

//HttpSessionEvent事件：
//取得当前操作的session
public HttpSession getSession();
</code></pre>

<p>HttpSessionAttributeListener接口：对session的属性监听。</p>

<pre><code class="java">public void attributeAdded(HttpSessionBindingEvent se);//增加属性
public void attributeRemoved(HttpSessionBindingEvent se);//删除属性
public void attributeReplaced(HttpSessionBindingEvent se);//替换属性

//HttpSessionBindingEvent事件：
public String getName();//取得属性的名称
public Object getValue();//取得属性的值
public HttpSession getSession();//取得当前的session
</code></pre>

<p>session的销毁有两种情况：</p>

<p>1.session超时，web.xml配置：</p>

<pre><code class="xml">&lt;session-config&gt;
    &lt;session-timeout&gt;120&lt;/session-timeout&gt;&lt;!--session120分钟后超时销毁--&gt;
&lt;/session-config&gt;
</code></pre>

<p>2.手工使session失效</p>

<pre><code class="java">//使session失效方法。session.invalidate();
public void invalidate();
</code></pre>

<h3>3、Request监听</h3>

<p>ServletRequestListener：用于对Request请求进行监听（创建、销毁）。</p>

<pre><code class="java">public void requestInitialized(ServletRequestEvent sre);//request初始化
public void requestDestroyed(ServletRequestEvent sre);//request销毁

//ServletRequestEvent事件：
public ServletRequest getServletRequest();//取得一个ServletRequest对象
public ServletContext getServletContext();//取得一个ServletContext（application）对象
</code></pre>

<p>ServletRequestAttributeListener：对Request属性的监听（增删改属性）。</p>

<pre><code class="java">public void attributeAdded(ServletRequestAttributeEvent srae);//增加属性
public void attributeRemoved(ServletRequestAttributeEvent srae);//属性删除
public void attributeReplaced(ServletRequestAttributeEvent srae);//属性替换（第二次设置同一属性）

//ServletRequestAttributeEvent事件：能取得设置属性的名称与内容
public String getName();//得到属性名称
public Object getValue();//取得属性的值
</code></pre>

<h3>4、在web.xml中配置</h3>

<p>Listener配置信息必须在Filter和Servlet配置之前，Listener的初始化（ServletContentListener初始化）比Servlet和Filter都优先，而销毁比Servlet和Filter都慢。</p>

<pre><code class="xml">&lt;listener&gt;
    &lt;listener-class&gt;com.listener.class&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>

<h2>Listener应用实例</h2>

<h3>1、利用HttpSessionListener统计最多在线用户人数</h3>

<pre><code class="java HttpSessionListenerImpl.java">import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import javax.servlet.ServletContext;
import javax.servlet.http.HttpSessionEvent;
import javax.servlet.http.HttpSessionListener;

public class HttpSessionListenerImpl implements HttpSessionListener {

    public void sessionCreated(HttpSessionEvent event) {
        ServletContext app = event.getSession().getServletContext();
        int count = Integer.parseInt(app.getAttribute("onLineCount").toString());
        count++;
        app.setAttribute("onLineCount", count);
        int maxOnLineCount = Integer.parseInt(app.getAttribute("maxOnLineCount").toString());
        if (count &gt; maxOnLineCount) {
            //记录最多人数是多少
            app.setAttribute("maxOnLineCount", count);
            DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            //记录在那个时刻达到上限
            app.setAttribute("date", df.format(new Date()));
        }
    }
    //session注销、超时时候调用，停止tomcat不会调用
    public void sessionDestroyed(HttpSessionEvent event) {
        ServletContext app = event.getSession().getServletContext();
        int count = Integer.parseInt(app.getAttribute("onLineCount").toString());
        count--;
        app.setAttribute("onLineCount", count);    

    }
}
</code></pre>

<h3>2、Spring使用ContextLoaderListener加载ApplicationContext配置信息</h3>

<p>ContextLoaderListener的作用就是启动Web容器时，自动装配ApplicationContext的配置信息。因为它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。</p>

<p>ContextLoaderListener如何查找ApplicationContext.xml的配置位置以及配置多个xml：如果在web.xml中不写任何参数配置信息，默认的路径是&#8221;/WEB-INF/applicationContext.xml&#8221;，在WEB-INF目录下创建的xml文件的名称必须是applicationContext.xml（在MyEclipse中把xml文件放置在src目录下）。如果是要自定义文件名可以在web.xml里加入contextConfigLocation这个context参数。</p>

<pre><code class="xml">&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath:spring/applicationContext-*.xml&lt;/param-value&gt;&lt;!-- 采用的是通配符方式，查找WEB-INF/spring目录下xml文件。如有多个xml文件，以“,”分隔。 --&gt;
&lt;/context-param&gt;
&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>

<h3>3、Spring使用Log4jConfigListener配置Log4j日志</h3>

<p>Spring使用Log4jConfigListener的好处：</p>

<ul>
<li>动态的改变记录级别和策略，不需要重启Web应用。</li>
<li>把log文件定在 /WEB-INF/logs/ 而不需要写绝对路径。因为系统把web目录的路径压入一个叫webapp.root的系统变量。这样写log文件路径时不用写绝对路径了。</li>
<li>可以把log4j.properties和其他properties一起放在/WEB-INF/ ，而不是Class-Path。</li>
<li>设置log4jRefreshInterval时间，开一条watchdog线程每隔段时间扫描一下配置文件的变化。</li>
</ul>


<pre><code class="xml">&lt;context-param&gt;
    &lt;param-name&gt;webAppRootKey&lt;/param-name&gt;
    &lt;param-value&gt;project.root&lt;/param-value&gt;&lt;!-- 用于定位log文件输出位置在web应用根目录下，log4j配置文件中写输出位置：log4j.appender.FILE.File=${project.root}/logs/project.log --&gt;
&lt;/context-param&gt;
&lt;context-param&gt;
    &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath:log4j.properties&lt;/param-value&gt;&lt;!-- 载入log4j配置文件 --&gt;
&lt;/context-param&gt;
&lt;context-param&gt;
    &lt;param-name&gt;log4jRefreshInterval&lt;/param-name&gt;
    &lt;param-value&gt;60000&lt;/param-value&gt;&lt;!--Spring刷新Log4j配置文件的间隔60秒,单位为millisecond--&gt;
&lt;/context-param&gt;
&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>

<h3>4、Spring使用IntrospectorCleanupListener清理缓存</h3>

<p>这个监听器的作用是在web应用关闭时刷新JDK的JavaBeans的Introspector缓存，以确保Web应用程序的类加载器以及其加载的类正确的释放资源。</p>

<p>如果JavaBeans的Introspector已被用来分析应用程序类，系统级的Introspector缓存将持有这些类的一个硬引用。因此，这些类和Web应用程序的类加载器在Web应用程序关闭时将不会被垃圾收集器回收！而IntrospectorCleanupListener则会对其进行适当的清理，已使其能够被垃圾收集器回收。</p>

<p>唯一能够清理Introspector的方法是刷新整个Introspector缓存，没有其他办法来确切指定应用程序所引用的类。这将删除所有其他应用程序在服务器的缓存的Introspector结果。</p>

<p>在使用Spring内部的bean机制时，不需要使用此监听器，因为Spring自己的introspection results cache将会立即刷新被分析过的JavaBeans Introspector cache，而仅仅会在应用程序自己的ClassLoader里面持有一个cache。虽然Spring本身不产生泄漏，注意，即使在Spring框架的类本身驻留在一个“共同”类加载器（如系统的ClassLoader）的情况下，也仍然应该使用使用IntrospectorCleanupListener。在这种情况下，这个IntrospectorCleanupListener将会妥善清理Spring的introspection cache。</p>

<p>应用程序类，几乎不需要直接使用JavaBeans Introspector，所以，通常都不是Introspector resource造成内存泄露。相反，许多库和框架，不清理Introspector，例如： Struts和Quartz。</p>

<p>需要注意的是一个简单Introspector泄漏将会导致整个Web应用程序的类加载器不会被回收！这样做的结果，将会是在web应用程序关闭时，该应用程序所有的静态类资源（比如：单实例对象）都没有得到释放。而导致内存泄露的根本原因其实并不是这些未被回收的类！</p>

<p>注意：IntrospectorCleanupListener应该注册为web.xml中的第一个Listener，在任何其他Listener之前注册，比如在Spring&rsquo;s ContextLoaderListener注册之前，才能确保IntrospectorCleanupListener在Web应用的生命周期适当时机生效。</p>

<pre><code class="xml">&lt;listener&gt;&lt;!-- memory clean --&gt;
    &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>

<p>作者：<a href="http://tianweili.github.io/">李天炜</a></p>

<p>原文链接：<a href="http://tianweili.github.io/blog/2015/01/27/java-listener/">http://tianweili.github.io/blog/2015/01/27/java-listener/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中的Filter 过滤器]]></title>
    <link href="http://tianweili.github.io/blog/2015/01/26/java-filter/"/>
    <updated>2015-01-26T17:07:51+08:00</updated>
    <id>http://tianweili.github.io/blog/2015/01/26/java-filter</id>
    <content type="html"><![CDATA[<p>本文主要详细介绍了Filter的以下几个方面内容：</p>

<ul>
<li>Filter概念介绍</li>
<li>Filter的用途</li>
<li>如何借助Filter实现拦截功能</li>
<li>Filter的开发步骤和配置详解</li>
<li>Filter链</li>
<li>Filter的生命周期</li>
<li>Filter的使用案例

<ul>
<li>使用Filter验证用户登录安全控制</li>
<li>防止中文乱码过滤器</li>
<li>Spring+Hibernate的OpenSessionInViewFilter控制session的开关</li>
<li>Struts2的web.xml配置</li>
</ul>
</li>
</ul>


<!--more-->


<p>原文链接：<a href="http://tianweili.github.io/blog/2015/01/26/java-filter/">http://tianweili.github.io/blog/2015/01/26/java-filter/</a></p>

<h2>Filter简介</h2>

<p>Filter也称之为过滤器，它是Servlet技术中最实用的技术，WEB开发人员通过Filter技术，对web服务器管理的所有web资源：例如Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能。例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。</p>

<p>它主要用于对用户请求进行预处理，也可以对HttpServletResponse 进行后处理。使用Filter 的完整流程：Filter 对用户请求进行预处理，接着将请求交给Servlet 进行处理并生成响应，最后Filter 再对服务器响应进行后处理。</p>

<h2>Filter功能</h2>

<ul>
<li>在HttpServletRequest 到达 Servlet 之前，拦截客户的 HttpServletRequest 。根据需要检查 HttpServletRequest ，也可以修改HttpServletRequest 头和数据。</li>
<li>在HttpServletResponse 到达客户端之前，拦截HttpServletResponse 。根据需要检查 HttpServletResponse ，也可以修改HttpServletResponse头和数据。</li>
</ul>


<h2>如何借助Filter实现拦截功能</h2>

<p>Filter接口中有一个doFilter方法，当开发人员编写好Filter，并配置对哪个web资源进行拦截后，WEB服务器每次在调用web资源的service方法之前，都会先调用一下filter的doFilter方法，因此，在该方法内编写代码可达到如下目的：</p>

<ul>
<li>调用目标资源之前，让一段代码执行。</li>
<li>是否调用目标资源（即是否让用户访问web资源）。</li>
</ul>


<p>web服务器在调用doFilter方法时，会传递一个filterChain对象进来，<strong>filterChain对象是filter接口中最重要的一个对象</strong>，它也提供了一个doFilter方法，开发人员可以根据需求决定是否调用此方法，调用该方法，则web服务器就会调用web资源的service方法，即web资源就会被访问，否则web资源不会被访问。</p>

<h2>Filter开发两步走</h2>

<ol>
<li>编写java类实现Filter接口，并实现其doFilter方法。</li>
<li>在 web.xml 文件中使用<filter>和<filter-mapping>元素对编写的filter类进行注册，并设置它所能拦截的资源。</li>
</ol>


<p>web.xml配置各节点介绍：</p>

<ul>
<li><code>&lt;filter&gt;</code>指定一个过滤器。

<ul>
<li><code>&lt;filter-name&gt;</code>用于为过滤器指定一个名字，该元素的内容不能为空。</li>
<li><code>&lt;filter-class&gt;</code>元素用于指定过滤器的完整的限定类名。</li>
<li><code>&lt;init-param&gt;</code>元素用于为过滤器指定初始化参数，它的子元素<code>&lt;param-name&gt;</code>指定参数的名字，<code>&lt;param-value&gt;</code>指定参数的值。</li>
<li>在过滤器中，可以使用<code>FilterConfig</code>接口对象来访问初始化参数。</li>
</ul>
</li>
<li><code>&lt;filter-mapping&gt;</code>元素用于设置一个 Filter 所负责拦截的资源。一个Filter拦截的资源可通过两种方式来指定：Servlet 名称和资源访问的请求路径

<ul>
<li><code>&lt;filter-name&gt;</code>子元素用于设置filter的注册名称。该值必须是在<code>&lt;filter&gt;</code>元素中声明过的过滤器的名字</li>
<li><code>&lt;url-pattern&gt;</code>设置 filter 所拦截的请求路径(过滤器关联的URL样式)</li>
</ul>
</li>
<li><code>&lt;servlet-name&gt;</code>指定过滤器所拦截的Servlet名称。</li>
<li><code>&lt;dispatcher&gt;</code>指定过滤器所拦截的资源被 Servlet 容器调用的方式，可以是<code>REQUEST</code>,<code>INCLUDE</code>,<code>FORWARD</code>和<code>ERROR</code>之一，默认<code>REQUEST</code>。用户可以设置多个<code>&lt;dispatcher&gt;</code>子元素用来指定 Filter 对资源的多种调用方式进行拦截。</li>
<li><code>&lt;dispatcher&gt;</code>子元素可以设置的值及其意义

<ul>
<li><code>REQUEST</code>：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过RequestDispatcher的include()或forward()方法访问时，那么该过滤器就不会被调用。</li>
<li><code>INCLUDE</code>：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。</li>
<li><code>FORWARD</code>：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。</li>
<li><code>ERROR</code>：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。</li>
</ul>
</li>
</ul>


<h2>Filter链</h2>

<p>在一个web应用中，可以开发编写多个Filter，这些Filter组合起来称之为一个Filter链。</p>

<p><strong>web服务器根据Filter在web.xml文件中的注册顺序，决定先调用哪个Filter</strong>，当第一个Filter的doFilter方法被调用时，web服务器会创建一个代表Filter链的FilterChain对象传递给该方法。在doFilter方法中，开发人员如果调用了FilterChain对象的doFilter方法，则web服务器会检查FilterChain对象中是否还有filter，如果有，则调用第2个filter，如果没有，则调用目标资源。</p>

<h2>Filter的生命周期</h2>

<pre><code class="java">public void init(FilterConfig filterConfig) throws ServletException;//初始化
</code></pre>

<p>和我们编写的Servlet程序一样，Filter的创建和销毁由WEB服务器负责。 web 应用程序启动时，web 服务器将创建Filter 的实例对象，并调用其init方法，读取web.xml配置，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作（<strong>filter对象只会创建一次，init方法也只会执行一次</strong>）。开发人员通过init方法的参数，可获得代表当前filter配置信息的FilterConfig对象。</p>

<pre><code class="java">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException;//拦截请求
</code></pre>

<p>这个方法完成实际的过滤操作。当客户请求访问与过滤器关联的URL的时候，Servlet过滤器将先执行doFilter方法。FilterChain参数用于访问后续过滤器。</p>

<pre><code class="java">public void destroy();//销毁
</code></pre>

<p>Filter对象创建后会驻留在内存，当web应用移除或服务器停止时才销毁。在Web容器卸载 Filter 对象之前被调用。该方法在Filter的生命周期中仅执行一次。在这个方法中，可以释放过滤器使用的资源。</p>

<h2>FilterConfig接口</h2>

<p>用户在配置filter时，可以使用<init-param>为filter配置一些初始化参数，当web容器实例化Filter对象，调用其init方法时，会把封装了filter初始化参数的filterConfig对象传递进来。因此开发人员在编写filter时，通过filterConfig对象的方法，就可获得以下内容：</p>

<pre><code class="java">String getFilterName();//得到filter的名称。 
String getInitParameter(String name);//返回在部署描述中指定名称的初始化参数的值。如果不存在返回null. 
Enumeration getInitParameterNames();//返回过滤器的所有初始化参数的名字的枚举集合。 
public ServletContext getServletContext();//返回Servlet上下文对象的引用。
</code></pre>

<h2>Filter使用案例</h2>

<h3>使用Filter验证用户登录安全控制</h3>

<p>前段时间参与维护一个项目，用户退出系统后，再去地址栏访问历史，根据url，仍然能够进入系统响应页面。我去检查一下发现对请求未进行过滤验证用户登录。添加一个filter搞定问题！</p>

<p>先在web.xml配置</p>

<pre><code class="XML web.xml">&lt;filter&gt;
    &lt;filter-name&gt;SessionFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;com.action.login.SessionFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;logonStrings&lt;/param-name&gt;&lt;!-- 对登录页面不进行过滤 --&gt;
        &lt;param-value&gt;/project/index.jsp;login.do&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;includeStrings&lt;/param-name&gt;&lt;!-- 只对指定过滤参数后缀进行过滤 --&gt;
        &lt;param-value&gt;.do;.jsp&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;redirectPath&lt;/param-name&gt;&lt;!-- 未通过跳转到登录界面 --&gt;
        &lt;param-value&gt;/index.jsp&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;disabletestfilter&lt;/param-name&gt;&lt;!-- Y:过滤无效 --&gt;
        &lt;param-value&gt;N&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;SessionFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>

<p>接着编写FilterServlet：</p>

<pre><code class="java FilterServlet.java">package com.action.login;

import java.io.IOException;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;

/**
 *    判断用户是否登录,未登录则退出系统
 */
public class SessionFilter implements Filter {

    public FilterConfig config;

    public void destroy() {
        this.config = null;
    }

    public static boolean isContains(String container, String[] regx) {
        boolean result = false;

        for (int i = 0; i &lt; regx.length; i++) {
            if (container.indexOf(regx[i]) != -1) {
                return true;
            }
        }
        return result;
    }

    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        HttpServletRequest hrequest = (HttpServletRequest)request;
        HttpServletResponseWrapper wrapper = new HttpServletResponseWrapper((HttpServletResponse) response);

        String logonStrings = config.getInitParameter("logonStrings");        // 登录登陆页面
        String includeStrings = config.getInitParameter("includeStrings");    // 过滤资源后缀参数
        String redirectPath = hrequest.getContextPath() + config.getInitParameter("redirectPath");// 没有登陆转向页面
        String disabletestfilter = config.getInitParameter("disabletestfilter");// 过滤器是否有效

        if (disabletestfilter.toUpperCase().equals("Y")) {    // 过滤无效
            chain.doFilter(request, response);
            return;
        }
        String[] logonList = logonStrings.split(";");
        String[] includeList = includeStrings.split(";");

        if (!this.isContains(hrequest.getRequestURI(), includeList)) {// 只对指定过滤参数后缀进行过滤
            chain.doFilter(request, response);
            return;
        }

        if (this.isContains(hrequest.getRequestURI(), logonList)) {// 对登录页面不进行过滤
            chain.doFilter(request, response);
            return;
        }

        String user = ( String ) hrequest.getSession().getAttribute("useronly");//判断用户是否登录
        if (user == null) {
            wrapper.sendRedirect(redirectPath);
            return;
        }else {
            chain.doFilter(request, response);
            return;
        }
    }

    public void init(FilterConfig filterConfig) throws ServletException {
        config = filterConfig;
    }
}
</code></pre>

<p>这样既可完成对用户所有请求，均要经过这个Filter进行验证用户登录。</p>

<h3>防止中文乱码过滤器</h3>

<p>项目使用spring框架时。当前台JSP页面和JAVA代码中使用了不同的字符集进行编码的时候就会出现表单提交的数据或者上传/下载中文名称文件出现乱码的问题，那就可以使用这个过滤器。</p>

<pre><code class="XML web.xml">&lt;filter&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;&lt;!--用来指定一个具体的字符集--&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;&lt;!--true：无论request是否指定了字符集，都是用encoding；false：如果request已指定一个字符集，则不使用encoding--&gt;
        &lt;param-value&gt;false&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>

<h3>Spring+Hibernate的OpenSessionInViewFilter控制session的开关</h3>

<p>当hibernate+spring配合使用的时候，如果设置了lazy=true（延迟加载）,那么在读取数据的时候，当读取了父数据后，hibernate 会自动关闭session，这样，当要使用与之关联数据、子数据的时候，系统会抛出lazyinit的错误，这时就需要使用spring提供的OpenSessionInViewFilter过滤器。</p>

<p>OpenSessionInViewFilter主要是保持Session状态直到request将全部页面发送到客户端，直到请求结束后才关闭session，这样就可以解决延迟加载带来的问题。</p>

<p>注意：OpenSessionInViewFilter配置要写在struts2的配置前面。因为tomcat容器在加载过滤器的时候是按照顺序加载的，如果配置文件先写的是struts2的过滤器配置，然后才是OpenSessionInViewFilter过滤器配置，所以加载的顺序导致，action在获得数据的时候session并没有被spring管理。</p>

<pre><code class="xml web.xml">&lt;filter&gt;&lt;!-- lazy loading enabled in spring --&gt;
    &lt;filter-name&gt;OpenSessionInViewFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.orm.hibernate3.support.OpenSessionInViewFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;sessionFactoryBeanName&lt;/param-name&gt;&lt;!-- 可缺省。默认是从spring容器中找id为sessionFactory的bean，如果id不为sessionFactory，则需要配置如下，此处SessionFactory为spring容器中的bean。 --&gt;
        &lt;param-value&gt;sessionFactory&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;singleSession&lt;/param-name&gt;&lt;!-- singleSession默认为true,若设为false则等于没用OpenSessionInView --&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;OpenSessionInViewFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>

<h3>Struts2的web.xml配置</h3>

<p>项目中使用Struts2同样需要在web.xml配置过滤器，用来截取请求，转到Struts2的Action进行处理。</p>

<p>注意：如果在2.1.3以前的Struts2版本，过滤器使用org.apache.struts2.dispatcher.FilterDispatcher。否则使用org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter。从Struts2.1.3开始，将废弃ActionContextCleanUp过滤器，而在StrutsPrepareAndExecuteFilter过滤器中包含相应的功能。</p>

<p>三个初始化参数配置：</p>

<ul>
<li>config参数：指定要加载的配置文件。逗号分割。</li>
<li>actionPackages参数：指定Action类所在的包空间。逗号分割。</li>
<li>configProviders参数：自定义配置文件提供者，需要实现ConfigurationProvider接口类。逗号分割。</li>
</ul>


<p>&#8220;`XML web.xml</p>

<!-- struts 2.x filter -->


<p><filter>
    <filter-name>struts2</filter-name>
    <filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>
</filter>
<filter-mapping>
    <filter-name>struts2</filter-name>
    <url-pattern>*.do</url-pattern>
</filter-mapping>
&#8220;`</p>

<p>作者：<a href="http://tianweili.github.io/">李天炜</a></p>

<p>原文链接：<a href="http://tianweili.github.io/blog/2015/01/26/java-filter/">http://tianweili.github.io/blog/2015/01/26/java-filter/</a></p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Design-pattern | 李天炜]]></title>
  <link href="http://tianweili.github.io/blog/categories/design-pattern/atom.xml" rel="self"/>
  <link href="http://tianweili.github.io/"/>
  <updated>2015-03-03T21:39:21+08:00</updated>
  <id>http://tianweili.github.io/</id>
  <author>
    <name><![CDATA[李天炜 litianwei2013[AT]gmail.com]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[单例模式的八种写法比较]]></title>
    <link href="http://tianweili.github.io/blog/2015/03/02/singleton-pattern/"/>
    <updated>2015-03-02T19:08:39+08:00</updated>
    <id>http://tianweili.github.io/blog/2015/03/02/singleton-pattern</id>
    <content type="html"><![CDATA[<p>单例模式是最常用到的设计模式之一，熟悉设计模式的朋友对单例模式都不会陌生。一般介绍单例模式的书籍都会提到<code>饿汉式</code>和<code>懒汉式</code>这两种实现方式。但是除了这两种方式，本文还会介绍其他几种实现单例的方式，让我们来一起看看吧。</p>

<!--more-->


<p>原文链接：<a href="http://tianweili.github.io/blog/2015/03/02/singleton-pattern/">http://tianweili.github.io/blog/2015/03/02/singleton-pattern/</a></p>

<h2>简介</h2>

<p>单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。</p>

<p>许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</p>

<h2>基本的实现思路</h2>

<p>单例模式要求类能够有返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）。</p>

<p>单例的实现主要是通过以下两个步骤：</p>

<ol>
<li>将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；</li>
<li>在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。</li>
</ol>


<h2>注意事项</h2>

<p>单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。</p>

<h2>单例模式的八种写法</h2>

<h3>1、饿汉式（静态常量）[可用]</h3>

<pre><code class="java">public class Singleton {

    private final static Singleton INSTANCE = new Singleton();

    private Singleton(){}

    public static Singleton getInstance(){
        return INSTANCE;
    }
}
</code></pre>

<p>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</p>

<p>缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。</p>

<h3>2、饿汉式（静态代码块）[可用]</h3>

<pre><code class="java">public class Singleton {

    private static Singleton instance;

    static {
        instance = new Singleton();
    }

    private Singleton() {}

    public Singleton getInstance() {
        return instance;
    }
}
</code></pre>

<p>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。</p>

<h3>3、懒汉式(线程不安全)[不可用]</h3>

<pre><code class="java">public class Singleton {

    private static Singleton singleton;

    private Singleton() {}

    public static Singleton getInstance() {
        if (singleton == null) {
            singleton = new Singleton();
        }
        return singleton;
    }
}
</code></pre>

<p>这种写法起到了Lazy Loading的效果，但是只能在单线程下使用。如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。</p>

<h3>4、懒汉式(线程安全，同步方法)[不推荐用]</h3>

<pre><code class="java">public class Singleton {

    private static Singleton singleton;

    private Singleton() {}

    public static synchronized Singleton getInstance() {
        if (singleton == null) {
            singleton = new Singleton();
        }
        return singleton;
    }
}
</code></pre>

<p>解决上面第三种实现方式的线程不安全问题，做个线程同步就可以了，于是就对getInstance()方法进行了线程同步。</p>

<p>缺点：效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。</p>

<h3>5、懒汉式(线程安全，同步代码块)[不可用]</h3>

<pre><code class="java">public class Singleton {

    private static Singleton singleton;

    private Singleton() {}

    public static Singleton getInstance() {
        if (singleton == null) {
            synchronized (Singleton.class) {
                singleton = new Singleton();
            }
        }
        return singleton;
    }
}
</code></pre>

<p>由于第四种实现方式同步效率太低，所以摒弃同步方法，改为同步产生实例化的的代码块。但是这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。</p>

<h3>6、双重检查[推荐用]</h3>

<pre><code class="java">public class Singleton {

    private static volatile Singleton singleton;

    private Singleton() {}

    public static Singleton getInstance() {
        if (singleton == null) {
            synchronized (Singleton.class) {
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
</code></pre>

<p>Double-Check概念对于多线程开发者来说不会陌生，如代码中所示，我们进行了两次if (singleton == null)检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象。</p>

<p>优点：线程安全；延迟加载；效率较高。</p>

<h3>7、静态内部类[推荐用]</h3>

<pre><code class="java">public class Singleton {

    private Singleton() {}

    private static class SingletonInstance {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonInstance.INSTANCE;
    }
}
</code></pre>

<p>这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有Lazy-Loading的作用，而静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。</p>

<p>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</p>

<p>优点：避免了线程不安全，延迟加载，效率高。</p>

<h3>8、枚举[推荐用]</h3>

<pre><code class="java">public enum Singleton {
    INSTANCE;
    public void whateverMethod() {

    }
}
</code></pre>

<p>借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。可能是因为枚举在JDK1.5中才添加，所以在实际项目开发中，很少见人这么写过。</p>

<h2>优点</h2>

<p>系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。</p>

<h2>缺点</h2>

<p>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new，可能会给其他开发人员造成困扰，特别是看不到源码的时候。</p>

<h2>适用场合</h2>

<ul>
<li>需要频繁的进行创建和销毁的对象；</li>
<li>创建对象时耗时过多或耗费资源过多，但又经常用到的对象；</li>
<li>工具类对象；</li>
<li>频繁访问数据库或文件的对象。</li>
</ul>


<p>作者：<a href="http://tianweili.github.com/">李天炜</a></p>

<p>原文链接：<a href="http://tianweili.github.io/blog/2015/03/02/singleton-pattern/">http://tianweili.github.io/blog/2015/03/02/singleton-pattern/</a></p>

<p>转载请注明作者及出处，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式六大原则 - 接口隔离原则]]></title>
    <link href="http://tianweili.github.io/blog/2015/02/10/interface-segregation-principle/"/>
    <updated>2015-02-10T23:01:20+08:00</updated>
    <id>http://tianweili.github.io/blog/2015/02/10/interface-segregation-principle</id>
    <content type="html"><![CDATA[<p>类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类B和类D来说不是最小接口，则类B和类D必须去实现他们不需要的方法。</p>

<!--more-->


<p>原文链接：<a href="http://tianweili.github.io/blog/2015/02/10/interface-segregation-principle/">http://tianweili.github.io/blog/2015/02/10/interface-segregation-principle/</a></p>

<h2>什么是接口隔离原则</h2>

<p>接口隔离原则比较简单，有两种定义：</p>

<ul>
<li>Clients should not be forced to depend upon interfaces that they don&rsquo;t use.（客户端不应该强行依赖它不需要的接口）</li>
<li>The dependency of one class to another one should depend on the smallest possible interface.（类间的依赖关系应该建立在最小的接口上）</li>
</ul>


<p>其实上述两种定义说的是同一种意思。客户端不应该依赖它不需要的接口，意思就是说客户端只要依赖它需要的接口，它需要什么接口，就提供什么接口，不提供多余的接口。“类间的依赖关系应该建立在最小的接口上”也表达这一层意思。通俗的讲就是：接口中的方法应该尽量少，不要使接口过于臃肿，不要有很多不相关的逻辑方法。</p>

<p>通过简单的代码还原开篇的问题，代码如下：</p>

<pre><code class="java">public interface I {
    public void method1();
    public void method2();
    public void method3();
}
public class B implements I{
 
    @Override
    public void method1() {
        System.out.println("类B实现了接口I的方法1");
    }
 
    @Override
    public void method2() {
        System.out.println("类B实现了接口I的方法2");
    }
 
    @Override
    public void method3() {//类B并不需要接口I的方法3功能，但是由于实现接口I，所以不得不实现方法3
        //在这里写一个空方法
    }
}
public class D implements I{
 
    @Override
    public void method2() {
        System.out.println("类D实现了接口I的方法2");
    }
 
    @Override
    public void method3() {
        System.out.println("类D实现了接口I的方法3");
    }
 
    @Override
    public void method1() {//类D并不需要接口I的方法1功能，但是由于实现接口I，所以不得不实现方法1
        //在这里写一个空方法
    }
}
//类A通过接口I依赖类B
public class A {
    public void depend1(I i){
        i.method1();
    }
}
//类C通过接口I依赖类D
public class C {
    public void depend1(I i){
        i.method3();
    }
}
public class Client {
    public static void main(String[] args) {
        A a = new A();
        I i1 = new B();
        a.depend1(i1);
         
        C c = new C();
        I i2 = new D();
        c.depend1(i2);
    }
}
</code></pre>

<p>运行结果：</p>

<pre><code>类B实现了接口I的方法1
类D实现了接口I的方法3
</code></pre>

<p>从以上代码可以看出，如果接口过于臃肿，不同业务逻辑的抽象方法都放在一个接口内，则会造成它的实现类必须实现自己并不需要的方法，这种设计方式显然是不妥当的。所以我们要修改上述设计方法，把接口I拆分成3个接口，使得实现类只需要实现自己需要的接口即可。只贴出修改后的接口和实现类的代码，修改代码如下：</p>

<pre><code class="java">public interface I1 {
    public void method1();
}
public interface I2 {
    public void method2();
}
public interface I3 {
    public void method3();
}
 
public class B implements I1,I2{
    @Override
    public void method1() {
        System.out.println("类B实现了接口I的方法1");
    }
 
    @Override
    public void method2() {
        System.out.println("类B实现了接口I的方法2");
    }
}
 
public class D implements I2,I3{
    @Override
    public void method2() {
        System.out.println("类D实现了接口I的方法2");
    }
 
    @Override
    public void method3() {
        System.out.println("类D实现了接口I的方法3");
    }
}
</code></pre>

<h2>与单一职责原则的区别</h2>

<p>到了这里，有些人可能觉得接口隔离原则与单一职责原则很相似，其实不然。</p>

<p>第一，单一职责原则注重的是职责；而接口隔离原则注重对接口依赖的隔离。</p>

<p>第二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口，主要针对抽象，针对程序整体框架的构建。</p>

<h2>注意事项</h2>

<p>原则是前人经验的总结，在软件设计中具有一定的指导作用，但是不能完全照搬这些原则。对于接口隔离原则来说，接口尽量小，但是也要有限度。对接口进行细化可以提高程序设计灵活性是不争的事实，但是如果过小，则会造成接口数量过多，使设计复杂化，所以一定要适度。</p>

<p>作者：<a href="http://tianweili.github.com/">李天炜</a></p>

<p>原文链接：<a href="http://tianweili.github.io/blog/2015/02/10/interface-segregation-principle/">http://tianweili.github.io/blog/2015/02/10/interface-segregation-principle/</a></p>

<p>转载请注明作者及出处，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式六大原则 - 依赖倒置原则]]></title>
    <link href="http://tianweili.github.io/blog/2015/02/07/dependence-inversion-principle/"/>
    <updated>2015-02-07T22:45:14+08:00</updated>
    <id>http://tianweili.github.io/blog/2015/02/07/dependence-inversion-principle</id>
    <content type="html"><![CDATA[<p>类A直接依赖于类B，假如要将类A修改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑。类B和C是底层模块，负责基本的原子操作。假如修改类A，将会给程序带来不必要的风险。而遵循依赖倒置原则的程序设计可以解决这一问题。</p>

<!--more-->


<p>原文链接：<a href="http://tianweili.github.io/blog/2015/02/07/dependence-inversion-principle/">http://tianweili.github.io/blog/2015/02/07/dependence-inversion-principle/</a></p>

<h2>什么是依赖倒置原则</h2>

<p>英文缩写DIP（Dependence Inversion Principle）。</p>

<p>原始定义：High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions.</p>

<p>翻译过来就三层含义：</p>

<ul>
<li>高层模块不应该依赖低层模块，两者都应该依赖其抽象；</li>
<li>抽象不应该依赖细节；</li>
<li>细节应该依赖抽象。</li>
</ul>


<p>抽象：即抽象类或接口，两者是不能够实例化的。</p>

<p>细节：即具体的实现类，实现接口或者继承抽象类所产生的类，两者可以通过关键字new直接被实例化。</p>

<p>现在我们来通过实例还原开篇问题的场景，以便更好的来理解。下面代码描述了一个简单的场景，Jim作为人有吃的方法，苹果有取得自己名字的方法，然后实现Jim去吃苹果。</p>

<p>代码如下：</p>

<pre><code class="java">//具体Jim人类
public class Jim {
    public void eat(Apple apple){
        System.out.println("Jim eat " + apple.getName());
    }
}
//具体苹果类
public class Apple {
    public String getName(){
        return "apple";
    }
}
public class Client {
    public static void main(String[] args) {
        Jim jim = new Jim();
        Apple apple = new Apple();
        jim.eat(apple);
    }
}
</code></pre>

<p>运行结果：Jim eat apple</p>

<p>上面代码看起来比较简单，但其实是一个非常脆弱的设计。现在Jim可以吃苹果了，但是不能只吃苹果而不吃别的水果啊，这样下去肯定会造成营养失衡。现在想让Jim吃香蕉了（好像香蕉里含钾元素比较多，吃点比较有益），突然发现Jim是吃不了香蕉的，那怎么办呢？看来只有修改代码了啊，由于上面代码中Jim类依赖于Apple类，所以导致不得不去改动Jim类里面的代码。那如果下次Jim又要吃别的水果了呢？继续修改代码？这种处理方式显然是不可取的，频繁修改会带来很大的系统风险，改着改着可能就发现Jim不会吃水果了。</p>

<p>上面的代码之所以会出现上述难堪的问题，就是因为Jim类依赖于Apple类，两者是紧耦合的关系，其导致的结果就是系统的可维护性大大降低。要增加香蕉类却要去修改Jim类代码，这是不可忍受的，你改你的代码为什么要动我的啊，显然Jim不乐意了。我们常说要设计一个健壮稳定的系统，而这里只是增加了一个香蕉类，就要去修改Jim类，健壮和稳定还从何谈起。</p>

<p>而根据依赖倒置原则，我们可以对上述代码做些修改，提取抽象的部分。首先我们提取出两个接口：People和Fruit，都提供各自必需的抽象方法，这样以后无论是增加Jim人类，还是增加Apple、Banana等各种水果，都只需要增加自己的实现类就可以了。由于遵循依赖倒置原则，只依赖于抽象，而不依赖于细节，所以增加类无需修改其他类。</p>

<p>代码如下：</p>

<pre><code class="java">//人接口
public interface People {
    public void eat(Fruit fruit);//人都有吃的方法，不然都饿死了
}
//水果接口
public interface Fruit {
    public String getName();//水果都是有名字的
}
//具体Jim人类
public class Jim implements People{
    public void eat(Fruit fruit){
        System.out.println("Jim eat " + fruit.getName());
    }
}
//具体苹果类
public class Apple implements Fruit{
    public String getName(){
        return "apple";
    }
}
//具体香蕉类
public class Banana implements Fruit{
    public String getName(){
        return "banana";
    }
}
public class Client {
    public static void main(String[] args) {
        People jim = new Jim();
        Fruit apple = new Apple();
        Fruit Banana = new Banana();//这里符合了里氏替换原则
        jim.eat(apple);
        jim.eat(Banana);
    }
}
</code></pre>

<p>运行结果：</p>

<pre><code>Jim eat apple
Jim eat banana
</code></pre>

<ul>
<li>People类是复杂的业务逻辑，属于高层模块，而Fruit是原子模块，属于低层模块。People依赖于抽象的Fruit接口，这就做到了：高层模块不应该依赖低层模块，两者都应该依赖于抽象（抽象类或接口）。</li>
<li>People和Fruit接口与各自的实现类没有关系，增加实现类不会影响接口，这就做到了：抽象（抽象类或接口）不应该依赖于细节（具体实现类）。</li>
<li>Jim、Apple、Banana实现类都要去实现各自的接口所定义的抽象方法，所以是依赖于接口的。这就做到了：细节（具体实现类）应该依赖抽象。</li>
</ul>


<h2>什么是倒置</h2>

<p>到了这里，我们对依赖倒置原则的“依赖”就很好理解了，但是什么是“倒置”呢。是这样子的，刚开始按照正常人的一般思维方式，我想吃香蕉就是吃香蕉，想吃苹果就吃苹果，编程也是这样，都是按照面向实现的思维方式来设计。而现在要倒置思维，提取公共的抽象，面向接口（抽象类）编程。不再依赖于具体实现了，而是依赖于接口或抽象类，这就是依赖的思维方式“倒置”了。</p>

<h2>依赖的三种实现方式</h2>

<p>对象的依赖关系有三种方式来传递：</p>

<h3>接口方法中声明依赖对象。</h3>

<p>就是我们上面代码所展示的那样。</p>

<h3>构造方法传递依赖对象。</h3>

<p>在构造函数中的需要传递的参数是抽象类或接口的方式实现。代码如下：</p>

<pre><code class="java">//具体Jim人类
public class Jim implements People{
     
    private Fruit fruit;
     
    public Jim(Fruit fruit){//构造方法传递依赖对象
        this.fruit = fruit;
    }
     
    public void eat(Fruit fruit){
        System.out.println("Jim eat " + this.fruit.getName());
    }
}
</code></pre>

<h3>Setter方法传递依赖对象。</h3>

<p>在我们设置的setXXX方法中的参数为抽象类或接口，来实现传递依赖对象。代码如下：</p>

<pre><code class="java">//具体Jim人类
public class Jim implements People{
     
    private Fruit fruit;
     
    public void setFruit(Fruit fruit){//setter方式传递依赖对象
        this.fruit = fruit;
    }
     
    public void eat(){
        System.out.println("Jim eat " + this.fruit.getName());
    }
}
</code></pre>

<h2>优点</h2>

<p>从上面的代码修改过程中，我们可以看到由于类之间松耦合的设计，面向接口编程依赖抽象而不依赖细节，所以在修改某个类的代码时，不会牵涉到其他类的修改，显著降低系统风险，提高系统健壮性。</p>

<p>还有一个优点是，在我们实际项目开发中，都是多人团队协作，每人负责某一模块。比如一个人负责开发People模块，一人负责开发Fruit模块，如果未采用依赖倒置原则，没有提取抽象，那么开发People模块的人必须等Fruit模块开发完成后自己才能开发，否则编译都无法通过，这就是单线程的开发。为了能够两人并行开发，设计时遵循依赖倒置原则，提取抽象，就可以大大提高开发进度。</p>

<h2>总结</h2>

<p>说到底，依赖倒置原则的核心就是面向接口编程的思想，尽量对每个实现类都提取抽象和公共接口形成接口或抽象类，依赖于抽象而不要依赖于具体实现。依赖倒置原则的本质其实就是通过抽象（抽象类或接口）使各个类或模块的实现彼此独立，不相互影响，实现模块间的松耦合。但是这个原则也是6个设计原则中最难以实现的了，如果没有实现这个原则，那么也就意味着开闭原则（对扩展开放，对修改关闭）也无法实现。</p>

<p>作者：<a href="http://tianweili.github.com/">李天炜</a></p>

<p>原文链接：<a href="http://tianweili.github.io/blog/2015/02/07/dependence-inversion-principle/">http://tianweili.github.io/blog/2015/02/07/dependence-inversion-principle/</a></p>

<p>转载请注明作者及出处，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式六大原则 - 里氏替换原则]]></title>
    <link href="http://tianweili.github.io/blog/2015/02/04/liskov-substitution-principle/"/>
    <updated>2015-02-04T22:34:39+08:00</updated>
    <id>http://tianweili.github.io/blog/2015/02/04/liskov-substitution-principle</id>
    <content type="html"><![CDATA[<p>我们都知道面向对象有三大特性：封装、继承、多态。所以我们在实际开发过程中，子类在继承父类后，根据多态的特性，可能是图一时方便，经常任意重写父类的方法，那么这种方式会大大增加代码出问题的几率。比如下面场景：类C实现了某项功能F1。现在需要对功能F1作修改扩展，将功能F1扩展为F，其中F由原有的功能F1和新功能F2组成。新功能F由类C的子类C1来完成，则子类C1在完成功能F的同时，有可能会导致类C的原功能F1发生故障。这时候里氏替换原则就闪亮登场了。</p>

<!--more-->


<p>原文链接：<a href="http://tianweili.github.io/blog/2015/02/04/liskov-substitution-principle/">http://tianweili.github.io/blog/2015/02/04/liskov-substitution-principle/</a></p>

<h2>什么是里氏替换原则</h2>

<p>前面说过的单一职责原则，从字面意思就很好理解，但是里氏替换原则就有点让人摸不着头脑。查过资料后发现原来这项原则最早是在1988年，由麻省理工学院一位姓里的女士（Liskov）提出来的。</p>

<p>英文缩写：LSP (Liskov Substitution Principle)。</p>

<p>严格的定义：如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都换成o2时，程序P的行为没有变化，那么类型T2是类型T1的子类型。</p>

<p>通俗的定义：所有引用基类的地方必须能透明地使用其子类的对象。</p>

<p>更通俗的定义：子类可以扩展父类的功能，但不能改变父类原有的功能。</p>

<p>代码示例</p>

<pre><code class="java">//抽象父类电脑
public abstract class Computer {
    public abstract void use();
}

class IBM extends Computer{
    @Override
    public void use() {
        System.out.println("use IBM Computer.");
    }
}

class HP extends Computer{
    @Override
    public void use() {
        System.out.println("use HP Computer.");
    }
}

public class Client{
    public static void main(String[] args) {
        Computer ibm = new IBM();
        Computer hp = new HP();//引用基类的地方能透明地使用其子类的对象。

        ibm.use();
        hp.use();
    }
}
</code></pre>

<h2>四层含义</h2>

<p>里氏替换原则包含以下4层含义：</p>

<ul>
<li>子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。</li>
<li>子类中可以增加自己特有的方法。</li>
<li>当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li>
<li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。
　　
现在我们可以对以上四层含义逐个讲解。</li>
</ul>


<h3>子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法</h3>

<p>在我们做系统设计时，经常会设计接口或抽象类，然后由子类来实现抽象方法，这里使用的其实就是里氏替换原则。子类可以实现父类的抽象方法很好理解，事实上，子类也必须完全实现父类的抽象方法，哪怕写一个空方法，否则会编译报错。</p>

<p>里氏替换原则的关键点在于不能覆盖父类的非抽象方法。父类中凡是已经实现好的方法，实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些规范，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。</p>

<p>在面向对象的设计思想中，继承这一特性为系统的设计带来了极大的便利性，但是由之而来的也潜在着一些风险。就像开篇所提到的那一场景一样，对于那种情况最好遵循里氏替换原则，类C1继承类C时，可以添加新方法完成新增功能，尽量不要重写父类C的方法。否则可能带来难以预料的风险，比如下面一个简单的例子还原开篇的场景：</p>

<pre><code class="java">public class C {
    public int func(int a, int b){
        return a+b;
    }
}

public class C1 extends C{
    @Override
    public int func(int a, int b) {
        return a-b;
    }
}

public class Client{
    public static void main(String[] args) {
        C c = new C1();
        System.out.println("2+1=" + c.func(2, 1));
    }
}
</code></pre>

<p>运行结果：2+1=1</p>

<p>上面的运行结果明显是错误的。类C1继承C，后来需要增加新功能，类C1并没有新写一个方法，而是直接重写了父类C的func方法，违背里氏替换原则，引用父类的地方并不能透明的使用子类的对象，导致运行结果出错。</p>

<h3>子类中可以增加自己特有的方法</h3>

<p>在继承父类属性和方法的同时，每个子类也都可以有自己的个性，在父类的基础上扩展自己的功能。前面其实已经提到，当功能扩展时，子类尽量不要重写父类的方法，而是另写一个方法，所以对上面的代码加以更改，使其符合里氏替换原则，代码如下：</p>

<pre><code class="java">public class C {
    public int func(int a, int b){
        return a+b;
    }
}

public class C1 extends C{
    public int func2(int a, int b) {
        return a-b;
    }
}

public class Client{
    public static void main(String[] args) {
        C1 c = new C1();
        System.out.println("2-1=" + c.func2(2, 1));
    }
}
</code></pre>

<p>运行结果：2-1=1</p>

<h3>当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松</h3>

<p>代码示例</p>

<pre><code class="java">import java.util.HashMap;
public class Father {
    public void func(HashMap m){
        System.out.println("执行父类...");
    }
}

import java.util.Map;
public class Son extends Father{
    public void func(Map m){//方法的形参比父类的更宽松
        System.out.println("执行子类...");
    }
}

import java.util.HashMap;
public class Client{
    public static void main(String[] args) {
        Father f = new Son();//引用基类的地方能透明地使用其子类的对象。
        HashMap h = new HashMap();
        f.func(h);
    }
}
</code></pre>

<p>运行结果：执行父类&hellip;</p>

<p>注意Son类的func方法前面是不能加@Override注解的，因为否则会编译提示报错，因为这并不是重写（Override），而是重载（Overload），因为方法的输入参数不同。重写和重载的区别在Java面向对象详解一文中已作解释，此处不再赘述。</p>

<h3>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格</h3>

<p>代码示例：</p>

<pre><code class="java">import java.util.Map;
public abstract class Father {
    public abstract Map func();
}

import java.util.HashMap;
public class Son extends Father{

    @Override
    public HashMap func(){//方法的返回值比父类的更严格
        HashMap h = new HashMap();
        h.put("h", "执行子类...");
        return h;
    }
}

public class Client{
    public static void main(String[] args) {
        Father f = new Son();//引用基类的地方能透明地使用其子类的对象。
        System.out.println(f.func());
    }
}
</code></pre>

<p>执行结果：{h=执行子类&hellip;}</p>

<h2>总结</h2>

<p>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了一些弊端，它增加了对象之间的耦合性。因此在系统设计时，遵循里氏替换原则，尽量避免子类重写父类的方法，可以有效降低代码出错的可能性。</p>

<p>作者：<a href="http://tianweili.github.com/">李天炜</a></p>

<p>原文链接：<a href="http://tianweili.github.io/blog/2015/02/04/liskov-substitution-principle/">http://tianweili.github.io/blog/2015/02/04/liskov-substitution-principle/</a></p>

<p>转载请注明作者及出处，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式六大原则 - 单一职责原则]]></title>
    <link href="http://tianweili.github.io/blog/2015/02/01/single-responsibility-principle/"/>
    <updated>2015-02-01T17:56:35+08:00</updated>
    <id>http://tianweili.github.io/blog/2015/02/01/single-responsibility-principle</id>
    <content type="html"><![CDATA[<p>初学者在编程的时候可能一开始会有这样的经历，使用一个类来实现很多的功能，新添加的甚至不相关的功能都放在一个类里来实现，煮成了一锅大杂烩，往往使得某个类包罗万象，无所不能。可能刚开始实现功能比较简单，这样做不会引发什么特别大的问题。但是随着项目复杂度的提升，各种不相关的实现代码耦合在一起，一旦有功能的更改或增删，修改的代码很可能会导致其他功能的正常运行。这种编程方式显然是不可取的，也就是违背了所谓的单一职责原则。</p>

<!--more-->


<p>原文链接：<a href="http://tianweili.github.io/blog/2015/02/25/single-responsibility-principle/">http://tianweili.github.io/blog/2015/02/25/single-responsibility-principle/</a></p>

<h2>什么是单一职责原则？</h2>

<p>单一职责原则的英文名称是Single Responsibility Principle，简称是SRP。SRP原则的解释是：There should never be more than one reason for a class to change。定义很简单，即不能存在多于一个导致类变更的原因。简单的说就是一个类只负责一项职责。</p>

<p>在软件设计中，秉承着“高内聚，低耦合”的思想，让一个类仅负责一项职责，如果一个类有多于一项的职责，那么就代表这个类耦合性变高了，这些职责耦合在了一起，这是比较脆弱的设计。因为一旦某一项职责发生了改变，需要去更改代码，那么有可能会引起其他职责改变。所谓牵一发而动全身，这显然是我们所不愿意看到的，所以我们会把这个类分拆开来，由两个类来分别维护这两个职责，这样当一个职责发生改变，需要修改时，不会影响到另一个职责。</p>

<p>需要说明的是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。</p>

<h2>关于职责</h2>

<p>看到上面所述，或许有人会说这么简单谁不知道。的确，很多程序员即使没有学过设计模式，不知道单一职责原则，在编程的时候，在设计软件时也会有意识的遵循这一原则。因为谁都不希望修改一个地方会引发另外一个地方出现问题，而避免这种问题的最好处理方式就是设计时遵循单一职责原则。但是，我认为单一职责原则的难点是在于职责范围的认定。关于职责的认定是一个仁者见仁智者见智的话题，在实际开发中也会引起程序员之间的争论。有的人认为这些功能方法的实现目的很相似，必须要放在一个类中，有的人认为方法差别很大，必须要分拆成多个类，在多个类里面来实现。</p>

<p>还有职责的扩散问题。软件一开发完上线后并不是一成不变的，随着社会的进步，需求的变更，软件的功能可能要做些维护更改，有时候会遇到职责扩散。所谓的职责扩散就是因为某种原因，职责R被分化为粒度更细的R1和R2。</p>

<p>比如类C只负责一个职责R，这是符合单一职责原则的。但是后来需要把职责R拆分为职责R1和职责R2，那么这时候是否需要死守着单一职责原则，把类C也拆开为C1和C2。接着如果R1又需要细化为R11和R12呢……</p>

<p>我们必须要意识到，一味的遵守单一职责原则，不停的分拆类所付出的开销是很大的。这时候就涉及到平衡的问题，平衡单一职责原则与修改造成的开销。我的观点是如果一个方法逻辑不复杂的情况下，可以修改方法实现，否则要拆分为两个方法，遵循方法级别的单一职责原则；如果一个类方法不多的情况下，可以只增加方法，而不用分拆为多个类，否则要拆分为多个类，遵循类级别的单一职责原则。</p>

<h2>遵循单一职责原则的优点</h2>

<ul>
<li>降低了类的复杂度。一个类只负责一项职责比负责多项职责要简单得多。</li>
<li>提高了代码的可读性。一个类简单了，可读性自然就提高了。</li>
<li>提高了系统的可维护性。代码的可读性高了，并且修改一项职责对其他职责影响降低了，可维护性自然就提高了。</li>
<li>变更引起的风险变低了。单一职责最大的优点就是修改一个功能，对其他功能的影响显著降低。</li>
</ul>


<p>作者：<a href="http://tianweili.github.com/">李天炜</a></p>

<p>原文链接：<a href="http://tianweili.github.io/blog/2015/02/25/single-responsibility-principle/">http://tianweili.github.io/blog/2015/02/25/single-responsibility-principle/</a></p>

<p>转载请注明作者及出处，谢谢。</p>
]]></content>
  </entry>
  
</feed>
